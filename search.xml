<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>黑马头条</title>
      <link href="/2023/06/13/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1/"/>
      <url>/2023/06/13/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马java面经总结</title>
      <link href="/2023/06/12/%E9%BB%91%E9%A9%ACjava%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/06/12/%E9%BB%91%E9%A9%ACjava%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="Redis的缓存问题"><a href="#Redis的缓存问题" class="headerlink" title="Redis的缓存问题"></a>Redis的缓存问题</h2><h3 id="Redis的穿透"><a href="#Redis的穿透" class="headerlink" title="Redis的穿透"></a>Redis的穿透</h3><p><b>Redis的穿透概念：</b>举个例子不陌生的例子：<b>网络攻击</b>，其中就可能是他人通过某些手段获取到了你的请求URL，然后用你的数据库<b>里面根本不存在的数据来疯狂访问你的项目</b>，又因为正常的项目都是在用户请求数据的时候先去Redis里面进行查询，查询不到了之后才会去数据库里面查询，数据库里面查询到之后会将数据放到Redis里面，这样用户下次的访问就可以在Redis里面进行快速的回应。这样就会发现黑客用大量的虚假数据进行访问时，就会都跳过Redis前往数据库进行查询，这样的话数据库的I&#x2F;O就会压力负载变大，当达到临界值的时候就会将数据库搞崩。这样就相当于<b>Redis被穿过去了直接将压力传递给了数据库</b>，所以这个问题就是Redis穿透问题。</p><p><b>Redis穿透问题的解决方法：</b></p><p><b>一：缓存空数据：</b>查询结果为空的时候仍把这个空数据进行缓存。<br>优点：简单。    缺点：消耗内存，可能会发生不一致的问题。</p><p><b>二：布隆过滤器</b><br>&amp;emsp; <b>运行原理：</b>比如在id查询时先通过查询布隆过滤器，如果不存在就直接返回，如果在布隆过滤器内存在才去Redis里面查询，（也就是在redis前查询前又加了一个过程），当然使用这种的话有一个关键的前提（缓存预热时还要对布隆过滤器进行预热）</p><p><b>布隆过滤器原理：</b>其实就是bitmap（位图）：一个以（bit）位为单位的数组，数组中每一个单位都只能存储0或1。预热时就是将一个一个值（id）进行多次hash函数后获取hash的值，然后将那个位置的值（hash后id）改成1。查询时就使用相同的hash函数进行获取hash值，判断hash值的位置是否位1，是就证明redis存在，不是则相反，当然这样的话肯定会存在误判（比如库里面只有1和2，hash后1对应的是1、3、5，2对应的是2、4、6，现在来了个3，hash后假如是：1、2、3，那么所有的值也是1，但是库里面却没有3的数据，这就是误判），所以布隆过滤器可以调整容错率。<br>优点：内存占用较小，没有多余的key。    缺点：存在误判的问题。</p><h3 id="Redis的击穿"><a href="#Redis的击穿" class="headerlink" title="Redis的击穿"></a>Redis的击穿</h3><p><b>Redis的击穿概念：</b>在现实使用中除了人为破坏当然还有<b>意外或者无意造成破坏</b>，其中就可能redis里面“碰巧”<b>出现一个数据过期后，同一时间大量数据进行访问</b>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又又又拉满了，当接近<b>“击穿电压”【临界值】</b>时数据库就会又被搞崩，所以这个问题就是Redis“击穿”问题【redis没有管理好“电压”，导致数据库“用电器”被击穿了】。</p><p><b>Redis击穿问题的解决方法：</b></p><p><b>一：添加互斥锁：</b>多个线程里面最先的那个先发现redis里面没有，申请互斥锁并成功，那么就去数据库查询，后面的线程虽然redis里面查询没有，但是因为申请不到互斥锁，就只能休眠一会，然后自动重新从头开始redis访问，当最前面的线程查询到数据库里面的数据，并且将数据写入缓存时，才释放互斥锁。<br>优点：强一致性。【不是绝对】    缺点：性能差【只有一个能拿到锁，其他都只能休眠，造成用户只能干等的局面】。  适用于银行金融，需要强一致性的场所。</p><p><b>二：逻辑过期</b>：其实就像萌新的我刚刚遇到这个问题，第一个想法就是<b>不设置过期时间</b>，但是这样的话redis里面的数据时效性就会被破坏，那么就<b>再添加一个字段为“保质期”</b>当后面程序拿到了这个数据，一分析居然是“过期的”就会去申请互斥锁，那么拿到互斥锁的那个线程就会，再多开一个新线程，新线程去数据库查询和写入缓存、释放锁操作。当然在这期间原本那个线程和后面申请不到互斥锁的线程就会带着过期的数据返回，不会盲目等待，可以先去干别。直到新线程重新写入缓存、修改逻辑、过期时间、后这个数据就可以使用了，再来进行访问。<br>优点：高可用性，性能也好。    缺点：一致性差。  适用于互联网这种高可用性的场所</p><h3 id="Redis的雪崩"><a href="#Redis的雪崩" class="headerlink" title="Redis的雪崩"></a>Redis的雪崩</h3><p><b>Redis的雪崩概念：</b>在实际使用redis时如果不规范，也会造成<b>意外或者无意</b>造成破坏，其中就可能redis里面“碰巧”<b >出现同一时间大量的缓存key同时失效或者redis宕机了</b>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又拉又满了，而导致的数据库的压力增大就是redis的雪崩。</p><p><b>Redis雪崩问题的解决方法：</b></p><p><b>一：给不同的key的TTl添加随机值：</b>从过期时间上面的更改。<br><b>二：利用Redis的集群提高服务的的可用性：</b>“哨兵模式”、“集群模式”从redis性能上面的更改。<br><b>三：给缓存业务添加降级限流策略：</b>使用“Nginx”、“spring cloud gateway”从业务上面进行更改。<br><b>四：给业务添加多级缓存：</b>“Guava”、“Caffeine”通过增加多级缓存。</p><h3 id="Redis的双写一致性"><a href="#Redis的双写一致性" class="headerlink" title="Redis的双写一致性"></a>Redis的双写一致性</h3><p>双写一致性其实就是：<b>如何保持redis和数据库的数据一致</b>。那么就是对数据库和缓存的数据更新处理。</p><p><b>双写一致性的方法：</b><br><b>一：延迟双删:</b><br>首先是为什么要进行延迟双删？因为如果只是数据库和redis的单次删除，那么无论如何处理（先删除数据库、先删除redis）都会导致数据的不一致导致脏读现象的出现。</p><p>先操作数据库再删除redis的话，理想的情况下是：当我们操作完数据库之后，并且将数据在redis里面删除，下一个线程查询不到redis里面的数据的时候，开始到数据库里面查询数据之后再写入redis里面，后面的的请求再在redis里面进行数据的获取。但是会出现一种情况就是当数据库被操作之前，redis里面的数据过期了或者被淘汰掉了，那么会有一个线程到数据库里面进行查询，这条线程查询到的是一个未被更新的数据，但是它还没有写入redis里面的时候我们进行了操作数据库和删除redis的操作，那么当我们结束后，读取到未被更新的数据的线程开始重新进行，将未被更新的数据写入redis里面，，导致之后出现脏读现象。<br>先删除redis后再操作数据库的话，理想情况下是：当我们删除数据和操作数据库之后，再来请求，发现reids里面没有数据，那么就会想数据库进行访问，然后再将数据库访问到的新数据写入到redis里面。但是会出现一种情况就是：当我们在删除redis数据完成之后，但是在书库操作之前，来了个线程，它先在redis里面查询发现没有数据，那么就会去数据库访问，但是我们还没有更新数据，就导致该线程查询到了未更新的数据，这是我们再进行是你出redis，操作数据库完成之后，查询到违背更新的数据的线程将数据返回并且还写入到redis里面，导致之后数据的脏读现象发生。</p><p>所以我们要避免脏读现象的出现最简单的就是“延迟双删”的操作，也和字面意思一样，当我们无论是先删除redis还是操作数据库，完成流程之后等一段时间再对reids进行二次删除，那么就不会再出现脏读的现象了。</p><p><b>二：分布式锁：</b><br>我们也可以进行加锁，首先是最简单的，无论是读还是写都要进行拿锁，拿到锁后才能进行数据对应的操作。（这样的话是强一致性，但是对于性能方面上是十分差的）</p><p>那么我们可以想一下redis里面的数据肯定是读多写少的数据，那么通过排他锁（读和写互斥）、共享锁（读读不互斥，写互斥）可以进一步提高性能。</p><p>当我们要进行读操作的时候进行添加共享锁，多个线程的读都不会影响，当进行写操作的时候添加一个排他锁，这样的话就读就无法进行，从而实现强一致性避免脏读，但是这样的话当我们进行写的时候读就无法进行，那么效率和性能还是很差的。是用在需要强一致性的场合才用。</p><p>当然除了强一致性的特殊场合，还有对一致性要求不高但是对性能要求高的场所，还有两种方案：</p><p><b>三：使用MQ：</b><br>当要修改数据的时候先是消息接受后，进行mysql的修改，修改后将消息发布给MQ，redis监听MQ消息进行更新缓存。这样的话对于数据的一致性就依靠于MQ的可靠性。</p><p><b>四：使用阿里的canal：</b><br>先是接受修改数据，写入数据库后，再通过canal对监听mysql的binlog，然后通知数据变更的情况进行缓存的更新。优点是对代码的零侵入，上面的多多少少多有对代码的侵入，</p><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>redis提供了两种的中持久化方式<b>RDB、AOF</b>其中的配置都在redis.conf里面进行具体的设置。</p><p><b>RDB</b>全称Redis Database Backup file（redis备份文件），也就是redis的数据快照，简单的来说就是将数据记录到磁盘中，这样的话当redis里面发生故障的时候，就可以从磁盘中通过读取快照文件快速恢复数据。<br>下面是主动备份的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save #由Redis主进程进行RDB，会阻塞所有的命令</span><br><span class="line">bgsave #开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><p>当然除了主动备份还有自动进行备份，在redis.conf里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#900秒内，如果至少又一个key被修改，则执行bgsave</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 1000</span><br></pre></td></tr></table></figure><p>RDB的执行机制就是：在bgsave进行时候先对主进程进行fork（copy-on-write技术）得到一个子进程，主进程和子进程fork时是对linux下特有的页表（虚拟内存映射关系表）拷贝，所以这个操作会特别快（阻塞也就时间很短），并且实现共享内存、可以同时对数据进行读操作，但是写操作是通过内存重新拷贝一个数据进行写操作，当然页表的对应关系也会更改，进而<br><b>AOF</b></p><h3 id="Redis的数据过期淘汰机制"><a href="#Redis的数据过期淘汰机制" class="headerlink" title="Redis的数据过期淘汰机制"></a>Redis的数据过期淘汰机制</h3><h2 id="Redis的分布式锁问题"><a href="#Redis的分布式锁问题" class="headerlink" title="Redis的分布式锁问题"></a>Redis的分布式锁问题</h2><h2 id="Redis的计数器"><a href="#Redis的计数器" class="headerlink" title="Redis的计数器"></a>Redis的计数器</h2><h2 id="Redis的保存Token、消息队列、延迟队列问题"><a href="#Redis的保存Token、消息队列、延迟队列问题" class="headerlink" title="Redis的保存Token、消息队列、延迟队列问题"></a>Redis的保存Token、消息队列、延迟队列问题</h2><h1 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h1><h2 id="Redis的集群模式"><a href="#Redis的集群模式" class="headerlink" title="Redis的集群模式"></a>Redis的集群模式</h2><h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><h2 id="Redis为什么这么块"><a href="#Redis为什么这么块" class="headerlink" title="Redis为什么这么块"></a>Redis为什么这么块</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>达内物联网框架</title>
      <link href="/2023/06/11/%E8%BE%BE%E5%86%85/"/>
      <url>/2023/06/11/%E8%BE%BE%E5%86%85/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="JDBC的认知"><a href="#JDBC的认知" class="headerlink" title="JDBC的认知"></a>JDBC的认知</h3><p>首先是为什么要使用ＪＤＢＣ？<br>JDBC:全称java database connectivity，是由SUN公司提供的一套操作数据库的标准规范。JDBC就是使用Java语言操作关系型数据库的一套API。所以：JDBC与数据库驱动的关系就像是接口与实现的关系。</p><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><p>JDBC规范（掌握四个核心对象，其实就是对应的类型）：<br>DriverManager:用于注册驱动<br>Connection: 表示与数据库创建的连接<br>Statement: 操作数据库sql语句的对象<br>ResultSet: 结果集或一张虚拟表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">DriverManager.registerDriver(new Driver());//这样的会导致被注册两次，因为源码上面就是注册了一次</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的优化"><a href="#JDBC的优化" class="headerlink" title="JDBC的优化"></a>JDBC的优化</h3><p>DriverManager.registerDriver(new com.mysql.jdbc.Driver())方法不建议使用原因有2个：一是：导致驱动被注册2次。二是：强烈依赖数据库的驱动jar。所以下面进行了优化：Class.forName(“com.mysql.jdbc.Driver”);同时又多了两种建立连接的方式：一：通过URl的路径方式方式：Class.forName(“com.mysql.jdbc.Driver”);二是：通过key-value键值对的形式包装再赋值：Properties info&#x3D;new Properties();info.setProperty(“user”, “root”);info.setProperty(“password”, “root”);Connection qiAo &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;gz”,info);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line"></span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line"></span><br><span class="line">Properties info=new Properties();</span><br><span class="line">info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">info.setProperty(&quot;password&quot;, &quot;root&quot;);</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,info);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的CRUD粗陋实现"><a href="#JDBC的CRUD粗陋实现" class="headerlink" title="JDBC的CRUD粗陋实现"></a>JDBC的CRUD粗陋实现</h3><p>Connection在返回结果时有两种常见方式：ResultSet类型的executeQuery(String sql)【这种的返回时用于sql里面的查询语句select语句时使用的返回方法，返回值是表类型的数据数据的开始为1】,int类型的executeUpdate(String sql)【这种的返回方法适用于增删改的操作，返回值是sql语句影响的条数】和一种boolean的方式boolean类型的execute(String sql)【返回值就是执行结果的对错，不能适合用在查询语句】 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//方法三增</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;insert into users(name,password,email,birthday) values(&#x27;zhaol&#x27;,&#x27;123456&#x27;,&#x27;zhaoliu@sina.com&#x27;,&#x27;1979-12-04&#x27;);&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法四删</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;DELETE FROM users WHERE users.id=4&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法五改</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;UPDATE users SET name=&#x27;null&#x27; WHERE id=5&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="JDBC的CRUD返回结果的包装"><a href="#JDBC的CRUD返回结果的包装" class="headerlink" title="JDBC的CRUD返回结果的包装"></a>JDBC的CRUD返回结果的包装</h3><p>其实是重拾java的内存结构（java各个属性的存放位置），java列表ArrayList的添加是地址添加不是值添加、以及泛型的定义：定义集合的存储类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义集合存放查到的数据    泛型:定义集合的存储类型</span><br><span class="line">ArrayList&lt;User&gt; list=new ArrayList();</span><br><span class="line">//5、处理结果,判断游标的下一行有没有数据有返回true反之 flase</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">User u=new User();</span><br><span class="line">u.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">u.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">u.setPassword(rs.getString(&quot;password&quot;));</span><br><span class="line">u.setEmail(rs.getString(&quot;email&quot;));</span><br><span class="line">u.setBirthday(rs.getDate(&quot;birthday&quot;));</span><br><span class="line">list.add(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="idea项目的配置"><a href="#idea项目的配置" class="headerlink" title="idea项目的配置"></a>idea项目的配置</h3><p>首先是新建项目，点击左上角的File，然后点击New和Project，新建项目先连续点击两次Next，然后就是项目名称、模板名字的命名了，Project name根据自己喜欢去命名，Module name根据需求进行命名。<br>然后就是配置了：<br>一：右键你的项目根目录，在下拉菜单里面找到你的Add Framework Support的选项，选择JEE下面的web选项，然后ok出来。<br>二：在项目里的web中的WEB-INF里面新建两个文件夹，一个是lib、另一个是classes。<br>三：点击左上角的File，在下拉菜单里面找到Project Structure并点击，在最左边选择Modules然后先选择最左边一栏的paths，选择Use module complie output path，并且将下面两个输入框都选择成上面在项目里面新建的classes的文件夹，最后点击右下角的Apply（不要退出）<br>四：点击Dependencies然后找到+号，点击添加JAR选择上面新建的lib文件夹，还有就是点击+号里面的librar将Tomcat添加到里面，在将添加那两个左边的选中框选上，后面可能会用到。<br>五：项目启动还没有配置，点击右上角绿色小锤子右边那个下拉框Edit Configurations，添加时在左边选择TomEE Server里面的Local，选中后将Applicattion server选择好我们的Tomcat的文件夹位置，最后再点击该窗口选项卡右边的Deployment，找到+号将四个菱形的选项添加上。</p><h3 id="idea使用Servlet的三种使用方式"><a href="#idea使用Servlet的三种使用方式" class="headerlink" title="idea使用Servlet的三种使用方式"></a>idea使用Servlet的三种使用方式</h3><p>在WEB-INF里面新建web.xml文件，每配置一个Servlet都要添加两个大标签<servlet>和<servlet-mapping>，前者是配置后者是访问路径，当用户通过URL的访问路径过来后先到<servlet-mapping>里面的对应的<url-pattern>然后再通过同<servlet-mapping>标签里面的<servlet-name>去找<servlet>相同的<servlet-name>，然后会再去到<servlet>相同标签下面的<servlet-class>，里面是我们Servlet对应项目的位置，通过这个去寻找项目里面对应的Servlet。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;!-- 配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet01&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet01&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!-- 配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet01&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet01&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;!--配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet02&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet02&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!--配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet02&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet02&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;!--配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet03&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet03&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!--配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet03&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet03&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>Servlet第一种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * servlet基于java语言开发的动态web资源的版本</span><br><span class="line"> * 本质上就是java代码</span><br><span class="line"> * 1入门：实现servlet接口的方式</span><br><span class="line"> *</span><br><span class="line"> * 生命周期：</span><br><span class="line"> * servlet在第一次被访问的时候创建</span><br><span class="line"> * 创建初servlet对象后，会立即调用init的当法进行初始化</span><br><span class="line"> * 之servlet后会一直驻留在内存中，为后续对该servlet的请求服务</span><br><span class="line"> * 每次请求此servlet都会造成方法的执行</span><br><span class="line"> * 知道服务器的关闭，或者web应用的移除、销毁servlet的销毁</span><br><span class="line"> * 销毁之前又会调用</span><br><span class="line"> * */</span><br><span class="line">public class Servlet01 implements Servlet &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 初始化的方法</span><br><span class="line">     * servlet容器在初始化servlet后立即执行的方法，进行初始化的操作</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(&quot;this is servlet01&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 就在这个里面进行接收，</span><br><span class="line">     * 业务处理的方法</span><br><span class="line">     * 每当有请求都会访问此方法，</span><br><span class="line">     * 接受代表请求的request的对象</span><br><span class="line">     * 代表相应的rsponse对象</span><br><span class="line">     * 在请求中获取数据 在响应中写出数据</span><br><span class="line">     * 可以在此方法中处理业务逻辑</span><br><span class="line">     *</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line"> * 销毁方法</span><br><span class="line"> * 在servlet对象在销毁的时候之前会调用这个方法</span><br><span class="line"> * */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;GG&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet第二种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建servlet的第二种方式</span><br><span class="line"> * 继承</span><br><span class="line"> * **/</span><br><span class="line">public class Servlet02 extends GenericServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Servlet02~~~~service~~~&quot;);</span><br><span class="line">        servletResponse.getWriter().write(new Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet第三种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建servlet的第三种方式</span><br><span class="line"> * 也是继承，但是需要进行重写方法</span><br><span class="line"> * **/</span><br><span class="line">public class Servlet03 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到GET请求，时间：&quot;+new Date());</span><br><span class="line">        //输出流</span><br><span class="line">        resp.getWriter().write(new Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个可以通过基本路径后面添加<url-pattern>里面的路径，进行使用。Servlet使用起来让我感觉和我使用的TCP里面的WebSocket时很像，主要的函数都是在开始前先调用一个方法，然后是每次访问都执行一个方法，还有就是结束销毁前进行一个方法。、</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="JSP的使用，注册页面的实现，页面的引用"><a href="#JSP的使用，注册页面的实现，页面的引用" class="headerlink" title="JSP的使用，注册页面的实现，页面的引用"></a>JSP的使用，注册页面的实现，页面的引用</h3><p>先是将css和img里面要用到的css格式和图片进行导入，以及head头标签、foot尾部标签、index主页、rigis注册页面的资源导入。</p><p>然后就是在index.jsp文件显示头部标签、尾部标签jsp文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入头部 --&gt;</span><br><span class="line">&lt;%@include file=&quot;_head.jsp&quot;%&gt;</span><br><span class="line">&lt;!-- 引入尾部 --&gt;</span><br><span class="line">&lt;%@include file=&quot;_foot.jsp&quot;%&gt;</span><br></pre></td></tr></table></figure><p>jsp文件其实就相当于servlet一样，可以在里面写入java代码，原理就和上面一样用一个&lt;%@ %&gt;的固定格式，当然也可以进行html的编写。</p><p>显然表单的检验，需要前端和后端两处进行验证，前端的验证是用来提醒用户、增强用户的体验。后端的验证是对于提交表单后的安全性验证，因为要避免恶意用户通过URl的方式直接在路径里面进行提交，那样的方式会避开前端的验证，所以后端的验证主要是对于安全性的考虑。</p><h3 id="先优化前端的代码，增强交互感觉"><a href="#先优化前端的代码，增强交互感觉" class="headerlink" title="先优化前端的代码，增强交互感觉"></a>先优化前端的代码，增强交互感觉</h3><p><b>先实现当用户提交信息的时候，对注册表单里面的数据进行非空的校验。</b></p><p>那么我们首先就要对表单提交后进行绑定事件，action里面是对应的servlet的，method里面是表单提交的方式，onsubmit里面就是表单提交在前端绑定的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;servlet/RegistServlet&quot; method=&quot;POST&quot; onsubmit=&quot;return checkForm()&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后就是进行checkForm前端方法的创建，通过script的便签和function创建函数。<br>函数里面要进行对表单数据非空判断，又因为我们的前端页面里面没有id字段只有name字段，那么就通过document.getElementsByName[0].value来拿到数据，var创建对象进行接收。<br>接收完数据又要对属性进行非空判断，使用if进行判断，判断完成后，如果通过弹窗提醒用户错误，那么就使用alert函数。<br>当然这样在多数据的表单里面太过于繁琐，所以我们可以先在新建一个空值的前端标签,里面进行一些设置，字体红色：style&#x3D;”color: red”这样方便用户直观的了解是错误填写提示，当然我们后面要对这个空标签赋值，那么我们需要一个唯一id进行命名，用于后面赋值：id&#x3D;”username_msg”格式为对应的输入栏的name值加上_msg，方便后期调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color: red&quot; id=&quot;username_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;color:red&quot; id=&quot;password_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;color:red&quot; id=&quot;password2_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">······</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们就不要用上面的弹窗提醒了，使用复制的形式进行页面显示报错信息提醒：document.getElementById(“username_msg”).innerText”&#x3D;用户名不能为空”，通过id的方式进行查找然后innerText进行附上需要的提示信息。代码如下面的注释里面的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class="line">function checkForm() &#123;</span><br><span class="line">    //拿到name是username的值</span><br><span class="line">    var username = document.getElementsByName(&quot;username&quot;)[0].value;</span><br><span class="line">    if (username == null || username==&quot;&quot;)&#123;</span><br><span class="line">        //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">        // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">        setMsg(&quot;username&quot;,&quot;用户名不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var password = document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    if (password == null || password==&quot;&quot;)&#123;</span><br><span class="line">        //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">        // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">        setMsg(&quot;username&quot;,&quot;密码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    ······</span><br><span class="line">    ······</span><br><span class="line">    return false;//不提交是因为我们的业务并没有做完</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之所以将他注释，是因为如果这样写法的话会非常多重复操作，造成代码的繁琐，那么我们就使用java的包装思想，进行相同代码的包装。那么应该知道我要做什么了吧，我们再创建一个setMsg函数进行获取显示的错误信息的标签操作，既然要获取对应的标签，我们需要先提供，本来的name，还有报错信息,具体方法就是上面的包装document.getElementById(id+”_msg”).innerText&#x3D;msg。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//封装的方法，用来获取某一篮对应要显示的错误信息</span><br><span class="line">    function setMsg(id,msg) &#123;</span><br><span class="line">        //将需要显示的错误信息进行显示</span><br><span class="line">        document.getElementById(id+&quot;_msg&quot;).innerText=msg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们进行了包装，但是我们还是需要进行var的创建、判断是否为空，不如我们在进行包装，判断非空交给另一个函数，我们只需要交给它name，如果错误要显示的错误信息就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function checkNull(name,msg)&#123;</span><br><span class="line">    var v=document.getElementsByName(name)[0].value;</span><br><span class="line">    if(v == null || v==&quot;&quot;)&#123;</span><br><span class="line">        //报错</span><br><span class="line">        setMsg(name,msg)</span><br><span class="line">        //到达这里说明等于空或者null，所以要返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //说明不为空或null</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们主函数就只需要传name和如果错误要显示的错误信息，但是我们如何判断其中都是T（去提交）还是其中有F（不让提交）呢？这时候我们使用递归的思想，创建一个canSub，开始我们给他true，后面的进行“与”的判断，T+T&#x3D;T，T+F&#x3D;F这样我们就实现了上面的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function checkForm() &#123;</span><br><span class="line">    // //拿到name是username的值</span><br><span class="line">    // var username = document.getElementsByName(&quot;username&quot;)[0].value;</span><br><span class="line">    // if (username == null || username==&quot;&quot;)&#123;</span><br><span class="line">    //      //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">    //     // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">    //     setMsg(&quot;username&quot;,&quot;用户名不能为空&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">    //</span><br><span class="line">    // var password = document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    // if (password == null || password==&quot;&quot;)&#123;</span><br><span class="line">    //     //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">    //     // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">    //     setMsg(&quot;username&quot;,&quot;密码不能为空&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    //用递归、与门的思想进行快速判断是否正确</span><br><span class="line">    //初始化一个“T”</span><br><span class="line">    var canSub=true;</span><br><span class="line">    //开始递归，从判断用户名开始，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;username&quot;,&quot;用户名不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    // checkNull(&quot;username&quot;,&quot;用户名不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断密码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;password&quot;,&quot;密码不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;password&quot;,&quot;密码不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认密码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;password2&quot;,&quot;确认密码不能为空&quot;)&amp;&amp; canSub;</span><br><span class="line">    //继续递归，开始判断确认名称，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;nickname&quot;,&quot;名称不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;nickname&quot;,&quot;名称不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认邮箱，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;email&quot;,&quot;邮箱不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;email&quot;,&quot;邮箱不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认验证码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;valistr&quot;,&quot;验证码不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;valistr&quot;,&quot;验证码不能会空&quot;)</span><br><span class="line"></span><br><span class="line">    //密码一致校验</span><br><span class="line">    var psw1=document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    var psw2=document.getElementsByName(&quot;password2&quot;)[0].value;</span><br><span class="line">    if(psw1!=null &amp;&amp; psw1!=&quot;&quot;&amp;&amp;psw2!=null &amp;&amp; psw2!=&quot;&quot;&amp;&amp; psw1!=psw2)&#123;</span><br><span class="line">        setMsg(&quot;password2&quot;,&quot;两次密码不一致&quot;)</span><br><span class="line">        canSub=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //邮箱格式的校验</span><br><span class="line">    var email=document.getElementsByName(&quot;email&quot;)[0].value;</span><br><span class="line">    if(email!=null &amp;&amp; email!=&quot;&quot; &amp;&amp; !/^\w+@\w+(\.\w+)+$/.test(email))&#123;</span><br><span class="line">        setMsg(&quot;email&quot;,&quot;邮箱的格式不正确&quot;)//报错</span><br><span class="line">        canSub=false;//结束提交</span><br><span class="line">    &#125;</span><br><span class="line">    return canSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们还在主函数里面进行了两次密码的一致性判断，还有邮箱格式的判断，原理一样只是邮箱用到了“&#x2F;^\w+@\w+(.\w+)+$&#x2F;.test(email)”的判断。</p><p>现在我们的提交表单后的判断就成功了，但是在提交表单前面我们没有提示，这样用户在第一次的使用就会繁琐。我们现在进行表单提交前填写信息时的判断操作。</p><p><b>表单提交前填写信息时的判断：</b></p><p>我们要使用到onblur，这个作用就是当鼠标的焦点在这个标签移除时进行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkNull(&#x27;username&#x27;,&#x27;用户名不能为空&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/08/hello-world/"/>
      <url>/2023/06/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客测试，我用的是<a href="https://hexo.io/">Hexo</a>的框架+git管理代码：<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上，我是win10的系统上从零搭建的同时参考大佬们的教程，现在对自己在该项目的所遇到的问题、常见命令进行总结和复习.</p><h2 id="下面是大致的流程"><a href="#下面是大致的流程" class="headerlink" title="下面是大致的流程"></a>下面是大致的流程</h2><h3 id="首先是Node-js的安装"><a href="#首先是Node-js的安装" class="headerlink" title="首先是Node.js的安装"></a>首先是Node.js的安装</h3><p>现在Node.js的官网下载你需要的版本，(本项目用的是v18.16.0，x64版本)然后一直Next进行下去(中间记得点击接受协议，还有选择安装的位置，“E:\NodeJS”是我的安装位置)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node</span><br></pre></td></tr></table></figure><p>当然，其实检查Node和Npm的版本还有其他的命令，但是这些命令，即使你已经配置好环境变量在普通cmd上直接运行会发现无法运行，那么我推荐你使用cmd的管理员模式运行，就可以运行起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装完成后需要进行配置环境变量：先右键点击“此电脑”选中“属性”，然后划到最下角点击“高级系统设置”，弹出一个弹窗后点击弹窗右下角的“环境变量”，就会又弹出的弹窗，在的下半部分找到变量为“Path”点击编辑，然后新建一个将Node.js安装目录放上去就行，然后一路确定回来，这样Node.js就安装好啦。</p><h3 id="还有是Node-js的下载调整"><a href="#还有是Node-js的下载调整" class="headerlink" title="还有是Node.js的下载调整"></a>还有是Node.js的下载调整</h3><p>还有一点就是npm的默认下载速度可能很慢，可以考虑将它换成淘宝镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><h3 id="然后就是hexo的安装"><a href="#然后就是hexo的安装" class="headerlink" title="然后就是hexo的安装"></a>然后就是hexo的安装</h3><p>直接上代码！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli g</span><br></pre></td></tr></table></figure><p>好啦，这样就将最基础的编辑环境配好了。</p><h3 id="现在让我们开始github上传配置（编码一小时，配置大半天）"><a href="#现在让我们开始github上传配置（编码一小时，配置大半天）" class="headerlink" title="现在让我们开始github上传配置（编码一小时，配置大半天）"></a>现在让我们开始github上传配置（编码一小时，配置大半天）</h3><p>首先是<a href="https://github.com/">github</a>上面注册一个账号。然后就是下载<a href="https://git-scm.com/download">git</a>。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
