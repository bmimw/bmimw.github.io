<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java基础面经</title>
      <link href="/2023/11/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/11/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是面向对象，以及你对面向对象的理解"><a href="#1-什么是面向对象，以及你对面向对象的理解" class="headerlink" title="1.什么是面向对象，以及你对面向对象的理解"></a>1.什么是面向对象，以及你对面向对象的理解</h1><p>面向对象和面向过程都是解决问题的一个方式，比如：我用洗衣机洗衣服。面向过程是：我拿来衣服、将衣服放入洗衣机、打开洗衣机。而面向对象则是：“我”和“洗衣机”以及“衣服”三个参与者创建三个对象，“我”这个对象里面有“拿取衣服”等方法，“洗衣机”有“清洗”等方法。所以从上面例子可以看出来<strong>面向过程更加注重于事情米一个步骤和过程。面向对象则注重于事情中有多少参与者，各自要干什么。</strong>面向过程比较直接效率更高。面向对象有更好的扩展、维护性。</p><p>面向对象的三大基础特征：封装、继承、多态。：</p><p>封装意义：明确指出外部可以调用的成员和函数，内部细节对外部调用透明，外部调用不需要关心内部实现。</p><p>封装例子：javabean的属性私有，需要提供get、set方法。因为属性的赋值和获取只能由javabean来决定防止外部胡乱修改。</p><p>继承：继承基类的方法，并可以提出自己的扩展。</p><p>多态：基于对象所属类不同，外部对同一个方法的调用，实际实现的逻辑不同。需要同时有：继承、重写、父类引用子类对象。</p><p>父类名称变量名&#x3D;new子类对象；</p><p>变量名.方法名();</p><p>缺点是无法使用子类特有的方法。</p><h1 id="2-String、StringBuffer、StringBuilder的区别和使用场景。"><a href="#2-String、StringBuffer、StringBuilder的区别和使用场景。" class="headerlink" title="2.String、StringBuffer、StringBuilder的区别和使用场景。"></a>2.String、StringBuffer、StringBuilder的区别和使用场景。</h1><p>String是不可变的类，当需要修改值时，一定会修改他的指向地址。</p><p>StringBuilder和StringBuffer的方法实现完全相同，区别在于StringBuffer有synchronized修饰是一个线程安全的类，而StringBuilder没有synchronized修饰理论上效率更高。StringBuilder（jdk1.5）StringBuffer（jdk1.0）</p><p>StringBuilder和StringBuffer可变是因为在源代码里面，当你创建一个类时会指向一个堆空间，堆空间有两个属性：value（记录具体的值）、count（记录使用多少个），两个数组。当value数组被占用满了，就会内部调用数组扩展，再创建一个更大的value数组，将之前的copy到新建的数组，value指向这个新的数组地址。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务面经</title>
      <link href="/2023/11/08/spring_cloud%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/11/08/spring_cloud%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-首先是spring-cloud的五大组件（分两种情况）："><a href="#1-首先是spring-cloud的五大组件（分两种情况）：" class="headerlink" title="1.首先是spring_cloud的五大组件（分两种情况）："></a>1.首先是spring_cloud的五大组件（分两种情况）：</h1><p><strong>一个是spring_cloud的</strong>：Eureka注册中心、<strong>Hystrix服务熔断降级</strong>、feign远程调用、Gateway网关、Ribbon负载均衡。</p><p><strong>一个是Alibba的</strong>：Nacos注册中心、<strong>sentinel服务保护</strong>、feign远程调用、Gateway网关、Ribbon负载均衡。</p><h1 id="2-Eureka注册中心和Nacos注册中心的原理和区别："><a href="#2-Eureka注册中心和Nacos注册中心的原理和区别：" class="headerlink" title="2.Eureka注册中心和Nacos注册中心的原理和区别："></a>2.Eureka注册中心和Nacos注册中心的原理和区别：</h1><p>Eureka原理：首先就是注册具体的服务信息到Eureka里面（包括服务的端口还有消费的端口）让Eureka来保存这些信息（服务名称、IP、端口号等等），然后服务的消费者也会在Eureka里面拉取服务的的端口号，如果服务提供者有集群就会根据负载均衡进行选择服务，先择之后就可以直接远程调用对应的服务了，期间服务会默认每隔30s向Eureka发送“心跳”，确保服务正常，如果Eureka注册中心的一个服务90s还没有接收到“心跳”就会将这个服务列表对应的端口号配置进行消除，这样消费者拉取信息的时候就不会拉取到这个以及宕机服务。</p><p>Nacos原理：也是先将服务信息（服务的提供者、消费着）注册到nacos注册中心，然后消费者定时拉取服务pull，如果有服务集群就会通过负载均衡进行选择，然后就可以直接远程调用，期间服务的提供者对Nacos进行“心跳”的发送，但是这些是<strong>启动Nacos的“临时实例”时的原理，和Eureka很像。当在spring_cloud配置为spring.cloud.nacos.discovery.ephemral:false时就启动了Nacos的非临时实例，这时候就会多出现几个步骤</strong>：首先是nacos会主动的询问服务的提供者是否存活，并且nacos会主动的进行推送变更消息push个与服务的消费者。这样更加会及时</p><p>Eureka和Nacos的共同点：1.都支持服务的注册和服务的拉取。2.都支持服务提供者以心跳的方式做健康检查。</p><p>Eureka和Nacos的不共同点：1.Nacos主动检测服务提供者的状态。2.临时实例不正常会剔除，但是非临时实例不正常也不会剔除。3.Nacos支持主动推送服务列表的变更消息。4.Nacos集群默认才用AP方式当存在非临时实例时才采用CP模式，Eureka采用的是AP方式。5.Nacos还支持了配置中心，而Eureka只有注册中心，这也是选择Nacos的一个重要的原因。（nacos内置了负载均衡，nacos的实例权重可以设置）</p><h1 id="3-Ribbon负载均衡策略有哪些？"><a href="#3-Ribbon负载均衡策略有哪些？" class="headerlink" title="3.Ribbon负载均衡策略有哪些？"></a>3.Ribbon负载均衡策略有哪些？</h1><p>首先负载均衡是：用户发情请求之后到Ribbon组件，Ribbon拉取服务，注册中心返回服务列表给予Ribbon，Ribbon再进行策略选择。期间都是在客户端进行的，（feign远程调用就是使用到了Ribbon）</p><p>策略：<strong>1.RRR简单的轮询服务列表进行选择服务器。2.WRTR按照权重进行选择服务器，响应时间越长权重越小。3.RR随机选择一个可用的服务器。4.ZAR以区域可用的服务器为基础进行选择，使用Zone对服务器进行选择，然后轮询。</strong>5.忽略短路服务器选择并发数较少的。6.重试机制进行选择7.先过滤非健康的在选择链接数较少的。</p><p>如何自定义负载均衡：1.全局生效的话：就创建一个返回类型IRule接口randomRule(){return new RandomRule();}，2.局部生效的话：在具体的一个服务的配置文件里进行配置userservice(具体的服务).ribbon.NFLoadBalancerRuleClassName:com,netflix.loadbalncer.RandomRule</p><h1 id="4-什么是服务雪崩，以及怎末解决这个问题："><a href="#4-什么是服务雪崩，以及怎末解决这个问题：" class="headerlink" title="4.什么是服务雪崩，以及怎末解决这个问题："></a>4.什么是服务雪崩，以及怎末解决这个问题：</h1><p>服务雪崩：就是当一个服务失败后，造成整条链路的服务都失败的情景（一个服务的连接数是一定的，当一个服务失败的连接数占满了那么就会导致这个服务不能使用了）。</p><p>解决方法：1.服务降级2.服务熔断（预防：限流）</p><p>服务降级：服务的自我保护一种方法，保护下游服务的一种方式，确保服务不会因为请求的突然暴增而变得不可用，确保服务不会崩溃，<strong>一般在实际开发中和fegin几口整合，编写降级逻辑</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;jshy-article&quot;,fallback = IArticleClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IArticleClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/api/v1/article/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">saveArticle</span><span class="params">(<span class="meta">@RequestBody</span> ArticleDto dto)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fallback 里面的就是降级逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IArticleClientFallback</span> <span class="keyword">implements</span> <span class="title class_">IArticleClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">saveArticle</span><span class="params">(ArticleDto dto)</span>  &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR,<span class="string">&quot;获取数据失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务熔断</strong>：默认关闭，需要手动打开（在引导类上面添加注解：@EnableCircuitBreaker），如果检查到10s内请求失败率超过50%，就会触发熔断。之后又会每隔5s重新进行尝试请求服务，如果可以就回复，还不可以就继续熔断。（主要是避免降级后还是有大量的请求过来，防止服务雪崩，直接将服务断掉，后面的请求直接拒绝掉）</p><h1 id="5-微服务通过什么进行监控的"><a href="#5-微服务通过什么进行监控的" class="headerlink" title="5.微服务通过什么进行监控的"></a>5.微服务通过什么进行监控的</h1><p>skywalking可以监控接口、服务、物理实例的一些窗台。在压测的时候可以看到众多服务中哪些服务和接口比较慢，以及接口是那个步骤慢（sql的慢查询判断）。skywalking还有告警规则，可以直接将报错通过发邮件、发短信的方式告知工作人员。</p><h1 id="6-项目中有没有限流？怎么做到的？"><a href="#6-项目中有没有限流？怎么做到的？" class="headerlink" title="6.项目中有没有限流？怎么做到的？"></a>6.项目中有没有限流？怎么做到的？</h1><p>限流：为了防止恶意攻击也是保护系统的正常进行。</p><p>限流方式：<strong>1.nginx的漏桶算法（以及控制并发连接数）。2.gateway的令牌桶算法。</strong>3.Tomcat设置最大连接数（默认200）4.自定义拦截器</p><p>漏桶算法：限制的是请求，可以设置桶的大小，最大访问速率等等。（开启Nodelay“快速处理”就会将超出桶大小的请求直接抛弃）</p><p>令牌桶：限制的是令牌（自己定义的生成速率，请求需要到令牌桶里面申请令牌），令牌满了就会暂停生成，（但是这样就会导致自定义的令牌a生成速率的并发数量2a情况出现：“原本令牌桶满了，每秒3个令牌，突然来了6个请求，直接取走三个，然后一秒内又生成了三个，那么一秒内就生成了六个请求”）</p><h1 id="7-解析一下CAP和BASE"><a href="#7-解析一下CAP和BASE" class="headerlink" title="7.解析一下CAP和BASE"></a>7.解析一下CAP和BASE</h1><p>CAP和BASE都是分布式失误方面的原理。</p><p>CAP：Consistency（一致性）：用户访问任意节点得到的数据一致。Availability（可用性）用户访问健康的节点都必须得到响应，而不是超时或者拒绝。Partition tolerance（区域容错性）因为网络的故障导致、其他原因导致分布式系统和其他节点失去连接，形成独立区域。但是出现这样的情况也需要持续的对外提供服务。</p><p>此三者只能满足其二（又因为分布式系统肯定是需要网络链接P是必须存在的）</p><p>BASE：BA（基本可用性）：分布式出现故障，允许损失部分可用性，保证核心可用性。S（软状态）：在一定时间里，允许出现中间状态（临时的不一致性）。E（最终一致性）：虽然无法保证强一致性，但是软状态结束后，最终达到数据一致。</p><h1 id="8-采用哪种分布式事务解决方案"><a href="#8-采用哪种分布式事务解决方案" class="headerlink" title="8.采用哪种分布式事务解决方案"></a>8.采用哪种分布式事务解决方案</h1><p>Seata框架（XA、AT、TCC），MQ</p><p>Seata事务管理其中三个重要角色：TC（事务协调者）：维护全局和分支事务的状态，协调全局失误提交或者回滚、TM（事务管理器）：定义全局事务的范围开始全局事务、提交或者回滚全局事务、RM（资源管理器）：管理分支事务处理的资源，与TC交谈以注册事务和报告分支事务的状态，并驱动分支事务提取或者回滚，“也是最小的事务单位，一个微服务相当一个RM”。</p><p>Seata的XA模式：1.TM开启全局事务TC。2.TM调用分支RM。3.RM注册分支事务到TC。4.RM执行业务sql但是不提交事务。5.RM执行将事务报告状态提交给TC。6.都成功就通知所有RM提交事件&#x2F;有失败就通知所有RM回滚事务。7.RM接收到TC指令，提交或回滚事务。</p><p>Seata的AT模式：1.TM开启全局事务TC。2.TM调用分支RM。3.RM注册分支事务到TC。4.RM记录undo-log（数据快照）。5.RM执行sql并直接事务。6.RM报告事务状态给TC。7.都成功就删除undo-log，有失败就根据undo-log回复数据到更新前的状态（回滚）。</p><p>Seata的TCC模式：1.TM开启全局事务TC。2.TM调用分支RM。3.RM注册分支事务到TC。4.RM进行Try（资源的检验和预留）。5.RM将事物的状态报告给TC。6.TC进行检查事务状态都成功就执行Confirm（完成资源操作业务：要求Try成功Confirm一定可以成功），有失败的话就Cancel（预留资源释放，可以理解为try的反向操作）。</p><h1 id="9-分布式接口幂等性图和设计？"><a href="#9-分布式接口幂等性图和设计？" class="headerlink" title="9.分布式接口幂等性图和设计？"></a>9.分布式接口幂等性图和设计？</h1><p>幂等：多次调用方法或者接口不会改变业务状态，<strong>保证重复调用和单词调用的结果一致</strong>。</p><p>基于RESTful API的角度对部分常见类型请求的幂等性特点进行分析：</p><table><thead><tr><th>请求方式</th><th>说明</th></tr></thead><tbody><tr><td>GET</td><td>查询操作天然幂等</td></tr><tr><td>POST</td><td>新增操作，请求一次与请求多次造成的结果不同，不是幂等</td></tr><tr><td>PUT</td><td>更新操作，如果是常数更新那么幂等，如果是通过增量更新的则不幂等</td></tr><tr><td>DELETE</td><td>删除操作，根据唯一值删除，是幂等</td></tr></tbody></table><p>幂等解决方式：数据库唯一索引（只能解决新增）、token+redis（新增和更新）、分布式锁（新增和更新，性能低）</p><p>token+redis的方式：<strong>在用户需要幂等请求前一个请求</strong>先进行：1.用户获取token。2.服务器生成唯一token（UUID）。3.将token存储到redis里面。4.将token给与客户端。然后<strong>到需要幂等的请求时</strong>：1.客户端先携带token发送请求。2.服务器验证token是否存在。3.存在token就删除token并处理业务。不存在就直接返回报错信息。</p><p>分布式锁：redis锁：redissonClient.getLock（获取锁），还需要手动释放锁lock.unlock。</p><h1 id="10-项目中的是用什么分布式任务调度。"><a href="#10-项目中的是用什么分布式任务调度。" class="headerlink" title="10.项目中的是用什么分布式任务调度。"></a>10.项目中的是用什么分布式任务调度。</h1><p>先描述什么情况下进行了任务调度（借呗给所有借贷人发送信息），xxj-job：任务量特别大分片进行，cron表达式灵活，定时任务失败了，重拾和统计，解决集群任务的重复执行问题。</p><p>xxl-job路由策略：<strong>1.ROUND轮询。2.FAILOVER故障转移:按照顺序依次进行心跳检测，第一个心跳检测成功的机器被选为目标执行器发起任务调度。3.分片广播：广播触发对应集群中的所有机器执行一次任务，同时系统会自动的传递分片参数，可以根据分片参数开发分片任务。</strong></p><p>xxl-job任务执行失败了要如何解决？</p><p>方案：故障转移+失败重试，查看日志分析—-&gt;邮件告警（人工处理）</p><p>如果有大量数据量的任务同时都需要进行执行，需要如何解决？：</p><p>让一个实例去执行（部署集群），路由策略选择分片广播。在任务执行的代码中可以获取分片总数以及当前的片数，按照取模的方式分摊到各个实例执行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/08/%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/11/08/%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jwt细致了解</title>
      <link href="/2023/10/26/jwt%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3/"/>
      <url>/2023/10/26/jwt%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT是什么？基本组成是什么？"><a href="#JWT是什么？基本组成是什么？" class="headerlink" title="JWT是什么？基本组成是什么？"></a>JWT是什么？基本组成是什么？</h2><p>JWT是JSON Web Token的缩写。它是一种用于安全地在两个实体之间传递信息的开放标准（RFC 7519）。这些信息可以被验证和信任，因为它是经过数字签名的。JWT通常用于在网络应用程序和服务之间传递身份验证信息和声明信息，确保数据在传输过程中不被篡改。</p><p>JWT是一个由三部分组成的字符串，这三部分之间用点（.）分隔开来：</p><ol><li><p><strong>Header（头部）</strong>：头部通常由两部分组成，第一部分是令牌的类型，通常是JWT，第二部分是所使用的签名算法，例如HMAC SHA256或RSA。</p><p>示例头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Payload（负载）</strong>：负载包含了要传输的声明信息。声明是关于实体（通常是用户）和其他数据的声明。有三种类型的声明：registered注册声明，public公共声明和private私有声明。</p></li></ol><ul><li><p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p></li><li><p>Public claims : 可以随意定义。</p></li><li><p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</p><p> 示例负载：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;iat&quot;: 1516239022</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p><strong>Signature（签名）</strong>：签名是使用头部中指定的算法和密钥对头部和负载进行签名生成的，以确保数据的完整性和真实性。签名的作用是防止数据在传输过程中被篡改。</p><p>签名示例（使用HMAC SHA256算法）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><p>在JWT中Signature（签名）可以看出，Header和Payload都会先被转换成JSON格式，然后再进行Base64编码。Base64编码是一种将二进制数据转换成可打印字符的编码方式，它将二进制数据按照固定的规则转换成文本字符串，这样可以确保数据在传输过程中不会被损坏。</p><p>所以，JWT的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base64UrlEncode(Header) + &quot;.&quot; + Base64UrlEncode(Payload) + &quot;.&quot; + Signature</span><br></pre></td></tr></table></figure><p>因此，一个典型的JWT看起来是这个样子的：xxxxx.yyyyy.zzzzz，并且私密的信息最好加密后再放到JWT的payload或header中。</p><p><strong>官网直观图：</strong></p><p><img src="/img/image-20210407203818808.png" alt="image-20210407203818808"></p><h2 id="JSON-Web-Tokens是如何具体工作的"><a href="#JSON-Web-Tokens是如何具体工作的" class="headerlink" title="JSON Web Tokens是如何具体工作的"></a>JSON Web Tokens是如何具体工作的</h2><p>JWT（JSON Web Tokens）的工作方式可以分为三个主要步骤：创建（Signing）、传输（Transmission）、验证（Verification）。</p><h3 id="1-创建（Signing）"><a href="#1-创建（Signing）" class="headerlink" title="1. 创建（Signing）:"></a>1. 创建（Signing）:</h3><ol><li><p><strong>头部和负载生成</strong>：首先，创建一个包含所需声明的 JSON 对象，这个对象即为 JWT 的负载（Payload）。同时，创建一个头部（Header）对象，指定签名算法（比如 HMAC SHA256 或 RSA）和令牌类型（通常是JWT）。</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Header<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Payload<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>生成签名</strong>：将Base64Url编码后的头部和负载连接起来，并使用指定的密钥和算法生成签名。签名的作用是确保数据在传输过程中不被篡改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，<code>base64UrlEncode()</code> 是Base64Url编码的函数，<code>secret</code> 是用于签名的密钥。</p></li><li><p><strong>生成JWT</strong>：将Base64Url编码后的头部、负载和签名用点（.）连接起来，形成最终的JWT字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base64UrlEncode(Header) + &quot;.&quot; + Base64UrlEncode(Payload) + &quot;.&quot; + Base64UrlEncode(Signature)</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-传输（Transmission）"><a href="#2-传输（Transmission）" class="headerlink" title="2. 传输（Transmission）:"></a>2. 传输（Transmission）:</h3><p>将生成的JWT字符串发送给接收者，通常通过HTTP头部信息或请求参数的形式传输。JWT通常放置在请求的Authorization头中（HTTP请求中的Authorization头部通常用于标识客户端请求的用户身份凭证），使用Bearer模式（Bearer模式是一种身份验证授权方式，它指示服务器请求中所携带的令牌（token）是JWT）。</p><p>示例如下：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;JWT&gt;</span><br></pre></td></tr></table></figure><p>   在这里，<code>&lt;JWT&gt;</code>代表实际的JSON Web Token。通过Bearer模式，服务器能够识别出请求中携带的身份凭证是JWT类型的令牌，并进行相应的验证和授权操作。</p><h3 id="3-验证（Verification）"><a href="#3-验证（Verification）" class="headerlink" title="3. 验证（Verification）:"></a>3. 验证（Verification）:</h3><p>接收者收到JWT后，可以按照以下步骤验证JWT的有效性：</p><ol><li><p><strong>解码JWT</strong>：接收者将JWT字符串按点（.）拆分为头部、负载和签名，并进行Base64Url解码，得到原始的头部和负载信息。</p></li><li><p><strong>验证签名</strong>：接收者使用相同的算法、密钥和头部中指定的签名算法验证签名的正确性。如果签名验证通过，表示JWT的发送者是可信的。</p></li><li><p><strong>验证声明</strong>：接收者验证负载中的声明，比如检查令牌是否过期（通过<code>exp</code>声明）、确认签发者的身份（通过<code>iss</code>声明）等。</p></li></ol><p>如果在解码、签名验证或声明验证的任何步骤中发现问题，JWT将被视为无效，接收者可以拒绝接受该令牌，确保应用程序的安全性。</p><h2 id="JSON-Web-Tokens的优点与缺点"><a href="#JSON-Web-Tokens的优点与缺点" class="headerlink" title="JSON Web Tokens的优点与缺点"></a>JSON Web Tokens的优点与缺点</h2><p>JSON Web Tokens（JWT）是一种在网络应用中广泛使用的身份验证和信息交换方式，它具有许多优点和一些限制。下面是JWT的优点和缺点：</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li><p><strong>轻量和简单</strong>：JWT是一种轻量级的数据交换格式，易于生成和解析。它的简单结构使得它在网络传输中非常高效。</p></li><li><p><strong>跨平台和跨语言</strong>：由于是基于JSON格式的标准，JWT可以在不同的平台和编程语言之间轻松传递和解析，提供了很好的跨平台互通性。</p></li><li><p><strong>无状态性（Stateless）</strong>：JWT是无状态的，服务器不需要在会话中保存用户的状态信息。所有的信息都被包含在JWT本  身中，这样可以减轻服务器的负担，提高了可伸缩性。如果JWT中包含了足够的必需数据，服务器可以减少对某些操作的数据库查询，因为它可以直接从JWT中获取所需信息，而无需查询数据库。这有助于提高性能。</p></li><li><p><strong>灵活性</strong>：JWT支持自定义声明，开发者可以根据需要在负载中包含任意信息，使得JWT非常灵活，可以用于各种场景。</p></li><li><p><strong>不依赖Cookie</strong>：JWT不依赖于浏览器的Cookie机制。当浏览器发起跨域请求时，如果请求中包含JWT，服务器可以验证JWT的有效性，并授权访问资源，而不受CORS的限制，因为JWT不被视为敏感的浏览器“凭证”。</p></li><li><p><strong>安全性</strong>：通过使用签名算法，JWT可以验证数据的完整性和真实性，确保信息在传输过程中不被篡改。这使得它成为一个相对安全的身份验证机制。</p></li><li><p><strong>分布式应用</strong>：由于JWT的特性，它非常适用于分布式系统，各个服务之间可以通过JWT进行身份验证和信息传递。</p></li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li><p><strong>无法撤销</strong>：一旦JWT被签发，就无法撤销或失效。即使在有效期内，如果用户的权限发生变化，服务器也无法立即撤销一个已签发的JWT。这个问题可以通过短有效期和额外的撤销机制来缓解。</p></li><li><p><strong>增加网络负担</strong>：由于每个请求都需要携带JWT，在网络传输中会增加一些额外的负担，尤其是在JWT较大时。</p></li><li><p><strong>敏感信息</strong>：尽管JWT的内容可以被加密，但是通常情况下，不应该在JWT中存储敏感信息，因为JWT可以被解码和读取。对于敏感信息，建议在服务器端进行处理。</p></li><li><p><strong>硬编码问题</strong>：如果JWT的密钥泄露，所有使用该密钥签发的JWT都会受到威胁。因此，密钥管理是使用JWT时需要特别注意的问题。</p></li></ol><p>综合考虑，JWT是一种强大的工具，但在使用时需要小心处理，特别是在处理敏感信息和密钥管理方面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马头条</title>
      <link href="/2023/06/13/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1/"/>
      <url>/2023/06/13/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis面经</title>
      <link href="/2023/06/12/redis%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/06/12/redis%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="Redis的缓存问题"><a href="#Redis的缓存问题" class="headerlink" title="Redis的缓存问题"></a>Redis的缓存问题</h2><h3 id="Redis的穿透"><a href="#Redis的穿透" class="headerlink" title="Redis的穿透"></a>Redis的穿透</h3><ul><li><p><strong>Redis的穿透概念：</strong>举个例子不陌生的例子：<strong>网络攻击</strong>，其中就可能是他人通过某些手段获取到了你的请求URL，然后用你的数据库<strong>里面根本不存在的数据来疯狂访问你的项目</strong>，又因为正常的项目都是在用户请求数据的时候先去Redis里面进行查询，查询不到了之后才会去数据库里面查询，数据库里面查询到之后会将数据放到Redis里面，这样用户下次的访问就可以在Redis里面进行快速的回应。这样就会发现黑客用大量的虚假数据进行访问时，就会都跳过Redis前往数据库进行查询，这样的话数据库的I&#x2F;O就会压力负载变大，当达到临界值的时候就会将数据库搞崩。这样就相当于<strong>Redis被穿过去了直接将压力传递给了数据库</strong>，所以这个问题就是Redis穿透问题。</p></li><li><p><strong>Redis穿透问题的解决方法：</strong></p><p>  <strong>一：缓存空数据：</strong>查询结果为空的时候仍把这个空数据进行缓存。<br>  优点：简单。    缺点：消耗内存，可能会发生不一致的问题。</p><p>  <strong>二：布隆过滤器</strong><br>  &amp;emsp; <strong>运行原理：</strong>比如在id查询时先通过查询布隆过滤器，如果不存在就直接返回，如果在布隆过滤器内存在才去Redis里面查询，（也就是在redis前查询前又加了一个过程），当然使用这种的话有一个关键的前提（缓存预热时还要对布隆过滤器进行预热）</p><p>  <strong>布隆过滤器原理：</strong>其实就是bitmap（位图）：一个以（bit）位为单位的数组，数组中每一个单位都只能存储0或1。预热时就是将一个一个值（id）进行多次hash函数后获取hash的值，然后将那个位置的值（hash后id）改成1。查询时就使用相同的hash函数进行获取hash值，判断hash值的位置是否位1，是就证明redis存在，不是则相反，当然这样的话肯定会存在误判（比如库里面只有1和2，hash后1对应的是1、3、5，2对应的是2、4、6，现在来了个3，hash后假如是：1、2、3，那么所有的值也是1，但是库里面却没有3的数据，这就是误判），所以布隆过滤器可以调整容错率。<br>  优点：内存占用较小，没有多余的key。    缺点：存在误判的问题。</p></li></ul><h3 id="Redis的击穿"><a href="#Redis的击穿" class="headerlink" title="Redis的击穿"></a>Redis的击穿</h3><ul><li><p><strong>Redis的击穿概念：</strong>在现实使用中除了人为破坏当然还有<strong>意外或者无意造成破坏</strong>，其中就可能redis里面“碰巧”<strong>出现一个数据过期后，同一时间大量数据进行访问</strong>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又又又拉满了，当接近<strong>“击穿电压”【临界值】</strong>时数据库就会又被搞崩，所以这个问题就是Redis“击穿”问题【redis没有管理好“电压”，导致数据库“用电器”被击穿了】。</p></li><li><p><strong>Redis击穿问题的解决方法：</strong></p><p>  <strong>一：添加互斥锁：</strong>多个线程里面最先的那个先发现redis里面没有，申请互斥锁并成功，那么就去数据库查询，后面的线程虽然redis里面查询没有，但是因为申请不到互斥锁，就只能休眠一会，然后自动重新从头开始redis访问，当最前面的线程查询到数据库里面的数据，并且将数据写入缓存时，才释放互斥锁。<br>  优点：强一致性。【不是绝对】    缺点：性能差【只有一个能拿到锁，其他都只能休眠，造成用户只能干等的局面】。  适用于银行金融，需要强一致性的场所。</p><p>  <strong>二：逻辑过期</strong>：其实就像萌新的我刚刚遇到这个问题，第一个想法就是<strong>不设置过期时间</strong>，但是这样的话redis里面的数据时效性就会被破坏，那么就<strong>再添加一个字段为“保质期”</strong>当后面程序拿到了这个数据，一分析居然是“过期的”就会去申请互斥锁，那么拿到互斥锁的那个线程就会，再多开一个新线程，新线程去数据库查询和写入缓存、释放锁操作。当然在这期间原本那个线程和后面申请不到互斥锁的线程就会带着过期的数据返回，不会盲目等待，可以先去干别。直到新线程重新写入缓存、修改逻辑、过期时间、后这个数据就可以使用了，再来进行访问。<br>  优点：高可用性，性能也好。    缺点：一致性差。  适用于互联网这种高可用性的场所</p></li></ul><h3 id="Redis的雪崩"><a href="#Redis的雪崩" class="headerlink" title="Redis的雪崩"></a>Redis的雪崩</h3><ul><li><p><strong>Redis的雪崩概念：</strong>在实际使用redis时如果不规范，也会造成<strong>意外或者无意</strong>造成破坏，其中就可能redis里面“碰巧”<b >出现同一时间大量的缓存key同时失效或者redis宕机了**，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又拉又满了，而导致的数据库的压力增大就是redis的雪崩。</p></li><li><p><strong>Redis雪崩问题的解决方法：</strong></p><p>  <strong>一：给不同的key的TTl添加随机值：</strong>从过期时间上面的更改。比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>  <strong>二：利用Redis的集群提高服务的的可用性：</strong>“哨兵模式”、“集群模式”从redis性能上面的更改。<br>  <strong>三：给缓存业务添加降级限流策略：</strong>使用“Nginx”、“spring cloud gateway”从业务上面进行更改。<br>  <strong>四：给业务添加多级缓存：</strong>“Guava”、“Caffeine”通过增加多级缓存。</p></li></ul><h3 id="Redis的双写一致性"><a href="#Redis的双写一致性" class="headerlink" title="Redis的双写一致性"></a>Redis的双写一致性</h3><ul><li><p>双写一致性其实就是：<strong>如何保持redis和数据库的数据一致</strong>。那么就是对数据库和缓存的数据更新处理。</p></li><li><p><strong>解决双写一致性的方法：</strong><br>  <strong>一. 延迟双删:</strong><br>  首先是为什么要进行延迟双删？因为如果只是数据库和redis的单次删除，那么无论如何处理（先删除数据库、先删除redis）都会导致数据的不一致导致脏读现象的出现。<br>  <strong>1. 先操作数据库再删除redis的话</strong>，理想的情况下是：当我们操作完数据库之后，并且将数据在redis里面删除，下一个线程查询不到redis里面的数据的时候，开始到数据库里面查询数据之后再写入redis里面，后面的的请求再在redis里面进行数据的获取。但是会出现一种情况就是当数据库被操作之前，redis里面的数据过期了或者被淘汰掉了，那么会有一个线程到数据库里面进行查询，这条线程查询到的是一个未被更新的数据，但是它还没有写入redis里面的时候我们进行了操作数据库和删除redis的操作，那么当我们结束后，读取到未被更新的数据的线程开始重新进行，将未被更新的数据写入redis里面，，导致之后出现脏读现象。<br>  <strong>2. 先删除redis后再操作数据库的话</strong>，理想情况下是：当我们删除数据和操作数据库之后，再来请求，发现reids里面没有数据，那么就会想数据库进行访问，然后再将数据库访问到的新数据写入到redis里面。但是会出现一种情况就是：当我们在删除redis数据完成之后，但是在书库操作之前，来了个线程，它先在redis里面查询发现没有数据，那么就会去数据库访问，但是我们还没有更新数据，就导致该线程查询到了未更新的数据，这是我们再进行是你出redis，操作数据库完成之后，查询到违背更新的数据的线程将数据返回并且还写入到redis里面，导致之后数据的脏读现象发生。<br>  所以我们要避免脏读现象的出现最简单的就是“延迟双删”的操作，也和字面意思一样，当我们无论是先删除redis还是操作数据库，完成流程之后等一段时间再对reids进行二次删除，那么就不会再出现脏读的现象了。</p><p>  <strong>二：分布式锁：</strong><br>  <strong>1. 线程锁</strong>我们也可以进行加锁，首先是最简单的，无论是读还是写都要进行拿锁，拿到锁后才能进行数据对应的操作。（这样的话是强一致性，但是对于性能方面上是十分差的）<br>  那么我们可以想一下redis里面的数据肯定是读多写少的数据，那么通过排他锁（读和写互斥）、共享锁（读读不互斥，写互斥）可以进一步提高性能。<br>  <strong>2. 读写锁</strong>当我们要进行读操作的时候进行添加共享锁，多个线程的读都不会影响，当进行写操作的时候添加一个排他锁（排他锁底层使用也是setnx），这样的话就读就无法进行，从而实现强一致性避免脏读，但是这样的话当我们进行写的时候读就无法进行，那么效率和性能还是很差的。是用在需要强一致性的场合才用。<br>  当然除了强一致性的特殊场合，还有对一致性要求不高但是对性能要求高的场所，还有两种方案：</p><p>  <strong>三：使用MQ：</strong><br>  当要修改数据的时候先是消息接受后，进行mysql的修改，修改后将消息发布给MQ，redis监听MQ消息进行更新缓存。这样的话对于数据的一致性就依靠于MQ的可靠性。</p><p>  <strong>四：使用阿里的canal：</strong><br>  先是接受修改数据，写入数据库后，再通过canal对监听mysql的binlog，然后通知数据变更的情况进行缓存的更新。优点是对代码的零侵入，上面的多多少少多有对代码的侵入。<br>  采用的阿里的canal组件实现数据同步：不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。</p></li></ul><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><ul><li><p>redis提供了两种的中持久化方式<strong>RDB、AOF</strong>其中的配置都在redis.conf里面进行具体的设置。</p><ol><li><p><strong>RDB</strong>全称Redis Database Backup file（redis备份文件），也就是redis的数据快照，简单的来说就是将数据记录到磁盘中，这样的话当redis里面发生故障的时候，就可以从磁盘中通过读取快照文件快速恢复数据。<br> 下面是主动备份的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save #由Redis主进程进行RDB，会阻塞所有的命令</span><br><span class="line">bgsave #开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><p> 当然除了主动备份还有自动进行备份，在redis.conf里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#900秒内，如果至少又一个key被修改，则执行bgsave</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 1000</span><br></pre></td></tr></table></figure><p> RDB的执行机制就是：在bgsave进行时候先对主进程进行fork得到一个子进程，这个过程期间会发生阻塞，（但是在linux操作系统下是不可以直接操作内存的）主进程和子进程fork时是对linux下特有的页表（虚拟内存与真实物理内存映射关系表）拷贝，所以这个操作会特别快（阻塞也就时间很短），并且实现共享内存、可以同时对数据进行读操作，（copy-on-write技术：）但是写操作是通过内存重新拷贝一个数据进行写操作，当然页表的对应关系也会更改，进而解决脏读发生。</p></li><li><p><strong>AOF</strong>全称为Append Only File（追加文件）。让redis所处理的每一个<strong>写命令</strong>的会被记录到AOF文件里面。但是默认是关闭，需要手动打开。</p></li></ol><p>  需要修改redis。conf配置文件<br>      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#是否开启AOF功能，默认是no</span><br><span class="line">appendonly yes</span><br><span class="line">#AOF文件名称</span><br><span class="line">appendfilename &quot;appenddonly.aof&quot;</span><br></pre></td></tr></table></figure></p><p>  当然AOF的记录命令的频率也可以在redis，conf文件里面进行配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#表示每执行一次写操作，立刻记录到AOF文件里面。</span><br><span class="line">appendfsync always</span><br><span class="line">#写命令执行完毕先放入AOF缓冲区然后表示每隔一秒将缓冲区的数据写到AOF文件里，是默认方案。</span><br><span class="line">appendfsync everysec</span><br><span class="line">#写命令执行完毕先放入AOF缓冲区域，有操作系统决定何时将缓冲数据写回磁盘。</span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>刷盘机制</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Always</td><td>同步刷盘</td><td>可靠性高，几乎不丢数据</td><td>性能影响较大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢失一秒的数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性较差，可能丢失大量数据</td></tr></tbody></table><p>  因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作（对同一key修改不同值，所有值都会记录），但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p>  Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># AOF文件比上次文件 增长超过多少百分比则触发重写auto-aof-rewrite-percentage 100</span><br><span class="line"># AOF文件体积最小多大以上才触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb </span><br></pre></td></tr></table></figure></p></li><li><p>RDB和AOF的优缺点：</p><table><thead><tr><th></th><th><strong>RDB</strong></th><th><strong>AOF</strong></th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table></li></ul><h3 id="Redis的数据过期策略"><a href="#Redis的数据过期策略" class="headerlink" title="Redis的数据过期策略"></a>Redis的数据过期策略</h3><ul><li><p>Redis的过期删除策略：<strong>惰性删除 + 定期删除两种策略进行配合使用</strong></p></li><li><p>惰性删除：设置该key过期时间后，redis就会不去管它，当再次需要该key时，redis会先检查其是否过期，如果过期，redis就删掉它，反之返回该key。<br>  优点 ：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查<br>  缺点 ：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该key就会一直存在内存中，内存永远不会释放</p></li><li><p>定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。<br>  定期清理有两种模式：</p><ol><li><strong>SLOW模式</strong>是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的hz 选项来调整这个次数</li><li><strong>FAST模式</strong>执行频率不固定，但两次间隔不低于2ms，每次耗时不超过1ms<br>  优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。<br>  缺点：难以确定删除操作执行的时长和频率。</li></ol></li></ul><h3 id="Redis的数据淘汰策略"><a href="#Redis的数据淘汰策略" class="headerlink" title="Redis的数据淘汰策略"></a>Redis的数据淘汰策略</h3><ul><li><p>数据的淘汰策略：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p></li><li><p>Redis支持8种不同策略来选择要删除的key：</p><ol><li><strong>noeviction（默认）：</strong> 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFU算法进行淘汰<br>  <strong>LRU（Least Recently Used）最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</strong><br>  <strong>LFU（Least Frequently Used）最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</strong></li></ol></li><li><p>使用建议：</p><ul><li>优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</li><li>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。</li><li>如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。</li><li>如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。</li></ul></li></ul><h2 id="Redis的分布式锁问题"><a href="#Redis的分布式锁问题" class="headerlink" title="Redis的分布式锁问题"></a>Redis的分布式锁问题</h2><ul><li><p>Redis实现分布式锁主要利用Redis的setnx命令。setnx是SET if not exists(如果不存在，则 SET)的简写。</p><p>  获取锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加锁，NX是互斥、EX是设置超时时间</span><br><span class="line">SET lock value NX EX 10</span><br></pre></td></tr></table></figure><p>  释放锁</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 释放锁，删除即可</span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li></ul><p>如果使用Redis实现分布式锁还需要合理的控制锁的有效时长，那么就需要使用redisson锁</p><ul><li><p>redisson实现的分布式锁-执行流程：也是先进行加锁，之后进行服务操作，才此期间会有<strong>看门狗（Watch dog）</strong>进行每隔(releaseTime &#x2F; 3)的时间做一次续期（默认10s续期一次）。此外的线程再进行加锁的时候，如果成功就进行上面的流程，<strong>如果失败就会while循环，不断尝试获取锁</strong>。（<strong>加锁、设置过期时间等操作都是基于lua脚本完成</strong>）</p><p>  当然redisson锁也可以进行自己设置过期时间，但是如果自己设置过期时间就会不再触发看门狗机制。</p></li><li><p>redisson实现的分布式锁-可重入<br>  redisson利用hash结构记录线程id和重入次数：KEY（唯一字段）和VALUE，VALUE下面还有field（当前线程的唯一标识）和value（重入次数）。</p></li><li><p>redisson实现的分布式锁-主从一致性</p><ul><li><p>redisson不能解决：线程1加锁成功后，master节点数据会异步复制到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。</p></li><li><p>但是可以使用redisson提供的红锁来解决，但是这样的话，性能就太低了，并且官方也暂时废弃了这个红锁，如果业务中非要保证数据的强一致性，建议采用zookeeper实现的分布式锁。</p></li><li><p>RedLock(红锁)：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁(n &#x2F; 2 + 1)，避免在一个redis实例上加锁。</p><ul><li>红锁实现逻辑：不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁。</li></ul></li></ul></li></ul><h1 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h1><h2 id="Redis的集群模式"><a href="#Redis的集群模式" class="headerlink" title="Redis的集群模式"></a>Redis的集群模式</h2><ul><li><p>在Redis中提供的集群方案总共有三种：</p><ol><li><p>主从复制(解决高并发)：</p><ul><li><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。（主节点用来执行写操作，从节点来进行读操作）</p></li><li><p>主从同步数据的流程：</p><ol><li><p>全量同步：</p><ol><li><p>执行replicaof命令，建立连接</p></li><li><p>从节点请求主节点同步数据（replication id、 offset ）</p></li></ol><p> Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid。</p><p> offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</p><ol start="3"><li><p>判断是否是第一次同步（即replication id是否一致）</p></li><li><p>是第一次，返回master的数据版本信息（replication id和offset）</p></li><li><p>主节点执行bgsave，生成rdb文件后，发送给从节点去执行</p></li><li><p>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区repl_baklog（一个日志文件）</p></li><li><p>把生成之后的命令日志文件发送给从节点进行同步</p></li></ol></li><li><p>增量同步：</p><ol><li><p>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</p></li><li><p>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</p></li></ol></li></ol></li></ul></li><li><p>哨兵模式(解决高可用)：</p></li></ol><ul><li><p>哨兵模式：实现主从集群的自动故障恢复（监控、自动故障恢复、通知）</p><ul><li><p>监控：Sentinel 会不断检查您的master和slave是否按预期工作</p></li><li><p>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</p></li><li><p>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</p></li></ul></li><li><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</p></li><li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。</p></li></ul></li><li><p>哨兵选主规则:</p><p>  首先判断主与从节点断开时间长短，如超过指定值就排该从节点，然后判断从节点的slave-priority值，越小优先级越高，如果slave-prority一样，则判断slave节点的offset值，越大优先级越高，最后是判断slave节点的运行id大小，越小优先级越高。</p></li><li><p>集群脑裂:</p><p>  集群脑裂是:由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失</p><p>  解决：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p></li></ul><ol start="3"><li><p>分片集群（海量数据存储问题、高并发写的问题）</p><ul><li><p>分片集群特征：</p><ol><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ol></li><li><p>Redis分片集群引入了哈希槽的概念，Redis集群有 16384 个哈希槽，根据key的有效部分计算哈希值，CRC16 校验后对16384取余（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）余数做为插槽，在哪个槽的哈希范围内就决定放置在哪里，集群的每个节点负责一部分 hash 槽。</p></li></ul></li></ol></li></ul><h2 id="Redis为什么这么块"><a href="#Redis为什么这么块" class="headerlink" title="Redis为什么这么块"></a>Redis为什么这么块</h2><ol><li><p>Redis是纯内存操作，执行速度非常快</p></li><li><p>采用单线程(5.7之前都是单线程，5.7之后非关键过程为多线程)，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</p></li><li><p>使用I&#x2F;O多路复用模型，非阻塞IO</p><p> Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度， I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p><ul><li><p>用户空间和内核空间：</p><ul><li><p>比如Linux系统中一个进程使用的内存情况划分两部分：内核空间、用户空间。</p></li><li><p>用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源</p></li><li><p>必须通过内核提供的接口来访问</p></li><li><p>内核空间可以执行特权命令（Ring0），调用一切系统资源</p></li><li><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li><li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li></ul></li></ul></li><li><p>常见的IO模型</p><ol><li><p>阻塞IO（Blocking IO）</p><ul><li>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</li></ul><p> 阶段一：<br> 用户进程尝试读取数据（比如网卡数据）<br> 此时数据尚未到达，内核需要等待数据<br> 此时用户进程也处于阻塞状态</p><p> 阶段二：<br> 数据到达并拷贝到内核缓冲区，代表已就绪<br> 将内核数据拷贝到用户缓冲区<br> 拷贝过程中，用户进程依然阻塞等待<br> 拷贝完成，用户进程解除阻塞，处理数据</p><p> 可以看到，阻塞IO模型中，用户进程在两个阶段都是阻塞状态。</p></li><li><p>非阻塞IO（Nonblocking IO）</p><ul><li>顾名思义，非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。</li></ul><p> 阶段一：<br> 用户进程尝试读取数据（比如网卡数据）<br> 此时数据尚未到达，内核需要等待数据<br> 返回异常给用户进程<br> 用户进程拿到error后，再次尝试读取<br> 循环往复，直到数据就绪</p><p> 阶段二：<br> 将内核数据拷贝到用户缓冲区<br> 拷贝过程中，用户进程依然阻塞等待<br> 拷贝完成，用户进程解除阻塞，处理数据</p><p> 可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增</p></li><li><p>IO多路复用（IO Multiplexing）</p><ul><li>IO多路复用：是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</li></ul><p> 阶段一：<br> 用户进程调用select，指定要监听的Socket集合<br> 内核监听对应的多个socket<br> 任意一个或多个socket数据就绪则返回readable<br> 此过程中用户进程阻塞</p><p> 阶段二：<br> 用户进程找到就绪的socket<br> 依次调用recvfrom读取数据<br> 内核将数据拷贝到用户空间<br> 用户进程处理数据</p><ul><li><p>IO多路复用是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听Socket的方式、通知的方式又有多种实现，常见的有：</p><ol><li>select</li><li>poll</li><li>epoll</li></ol><ul><li>差异：</li></ul><ol><li>select和poll只会通知用户进程有Socket就绪，但不确定具体是哪个Socket ，需要用户进程逐个遍历Socket来确认</li><li>epoll则会在通知用户进程Socket就绪的同时，把已就绪的Socket写入用户空间</li></ol></li></ul></li></ol></li><li><p>Redis网络模型</p></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC框架</title>
      <link href="/2023/06/11/%E8%BE%BE%E5%86%85/"/>
      <url>/2023/06/11/%E8%BE%BE%E5%86%85/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="JDBC的认知"><a href="#JDBC的认知" class="headerlink" title="JDBC的认知"></a>JDBC的认知</h3><p>首先是为什么要使用ＪＤＢＣ？<br>JDBC:全称java database connectivity，是由SUN公司提供的一套操作数据库的标准规范。JDBC就是使用Java语言操作关系型数据库的一套API。所以：JDBC与数据库驱动的关系就像是接口与实现的关系。</p><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><p>JDBC规范（掌握四个核心对象，其实就是对应的类型）：<br>DriverManager:用于注册驱动<br>Connection: 表示与数据库创建的连接<br>Statement: 操作数据库sql语句的对象<br>ResultSet: 结果集或一张虚拟表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">DriverManager.registerDriver(new Driver());//这样的会导致被注册两次，因为源码上面就是注册了一次</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的优化"><a href="#JDBC的优化" class="headerlink" title="JDBC的优化"></a>JDBC的优化</h3><p>DriverManager.registerDriver(new com.mysql.jdbc.Driver())方法不建议使用原因有2个：一是：导致驱动被注册2次。二是：强烈依赖数据库的驱动jar。所以下面进行了优化：Class.forName(“com.mysql.jdbc.Driver”);同时又多了两种建立连接的方式：一：通过URl的路径方式方式：Class.forName(“com.mysql.jdbc.Driver”);二是：通过key-value键值对的形式包装再赋值：Properties info&#x3D;new Properties();info.setProperty(“user”, “root”);info.setProperty(“password”, “root”);Connection qiAo &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;gz”,info);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line"></span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line"></span><br><span class="line">Properties info=new Properties();</span><br><span class="line">info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">info.setProperty(&quot;password&quot;, &quot;root&quot;);</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,info);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的CRUD粗陋实现"><a href="#JDBC的CRUD粗陋实现" class="headerlink" title="JDBC的CRUD粗陋实现"></a>JDBC的CRUD粗陋实现</h3><p>Connection在返回结果时有两种常见方式：ResultSet类型的executeQuery(String sql)【这种的返回时用于sql里面的查询语句select语句时使用的返回方法，返回值是表类型的数据数据的开始为1】,int类型的executeUpdate(String sql)【这种的返回方法适用于增删改的操作，返回值是sql语句影响的条数】和一种boolean的方式boolean类型的execute(String sql)【返回值就是执行结果的对错，不能适合用在查询语句】 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//方法三增</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;insert into users(name,password,email,birthday) values(&#x27;zhaol&#x27;,&#x27;123456&#x27;,&#x27;zhaoliu@sina.com&#x27;,&#x27;1979-12-04&#x27;);&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法四删</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;DELETE FROM users WHERE users.id=4&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法五改</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;UPDATE users SET name=&#x27;null&#x27; WHERE id=5&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="JDBC的CRUD返回结果的包装"><a href="#JDBC的CRUD返回结果的包装" class="headerlink" title="JDBC的CRUD返回结果的包装"></a>JDBC的CRUD返回结果的包装</h3><p>其实是重拾java的内存结构（java各个属性的存放位置），java列表ArrayList的添加是地址添加不是值添加、以及泛型的定义：定义集合的存储类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义集合存放查到的数据    泛型:定义集合的存储类型</span><br><span class="line">ArrayList&lt;User&gt; list=new ArrayList();</span><br><span class="line">//5、处理结果,判断游标的下一行有没有数据有返回true反之 flase</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">User u=new User();</span><br><span class="line">u.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">u.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">u.setPassword(rs.getString(&quot;password&quot;));</span><br><span class="line">u.setEmail(rs.getString(&quot;email&quot;));</span><br><span class="line">u.setBirthday(rs.getDate(&quot;birthday&quot;));</span><br><span class="line">list.add(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="idea项目的配置"><a href="#idea项目的配置" class="headerlink" title="idea项目的配置"></a>idea项目的配置</h3><p>首先是新建项目，点击左上角的File，然后点击New和Project，新建项目先连续点击两次Next，然后就是项目名称、模板名字的命名了，Project name根据自己喜欢去命名，Module name根据需求进行命名。<br>然后就是配置了：<br>一：右键你的项目根目录，在下拉菜单里面找到你的Add Framework Support的选项，选择JEE下面的web选项，然后ok出来。<br>二：在项目里的web中的WEB-INF里面新建两个文件夹，一个是lib、另一个是classes。<br>三：点击左上角的File，在下拉菜单里面找到Project Structure并点击，在最左边选择Modules然后先选择最左边一栏的paths，选择Use module complie output path，并且将下面两个输入框都选择成上面在项目里面新建的classes的文件夹，最后点击右下角的Apply（不要退出）<br>四：点击Dependencies然后找到+号，点击添加JAR选择上面新建的lib文件夹，还有就是点击+号里面的librar将Tomcat添加到里面，在将添加那两个左边的选中框选上，后面可能会用到。<br>五：项目启动还没有配置，点击右上角绿色小锤子右边那个下拉框Edit Configurations，添加时在左边选择TomEE Server里面的Local，选中后将Applicattion server选择好我们的Tomcat的文件夹位置，最后再点击该窗口选项卡右边的Deployment，找到+号将四个菱形的选项添加上。</p><h3 id="idea使用Servlet的三种使用方式"><a href="#idea使用Servlet的三种使用方式" class="headerlink" title="idea使用Servlet的三种使用方式"></a>idea使用Servlet的三种使用方式</h3><p>在WEB-INF里面新建web.xml文件，每配置一个Servlet都要添加两个大标签<servlet>和<servlet-mapping>，前者是配置后者是访问路径，当用户通过URL的访问路径过来后先到<servlet-mapping>里面的对应的<url-pattern>然后再通过同<servlet-mapping>标签里面的<servlet-name>去找<servlet>相同的<servlet-name>，然后会再去到<servlet>相同标签下面的<servlet-class>，里面是我们Servlet对应项目的位置，通过这个去寻找项目里面对应的Servlet。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;!-- 配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet01&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet01&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!-- 配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet01&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet01&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;!--配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet02&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet02&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!--配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet02&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet02&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;!--配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet03&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet03&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!--配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet03&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet03&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>Servlet第一种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * servlet基于java语言开发的动态web资源的版本</span><br><span class="line"> * 本质上就是java代码</span><br><span class="line"> * 1入门：实现servlet接口的方式</span><br><span class="line"> *</span><br><span class="line"> * 生命周期：</span><br><span class="line"> * servlet在第一次被访问的时候创建</span><br><span class="line"> * 创建初servlet对象后，会立即调用init的当法进行初始化</span><br><span class="line"> * 之servlet后会一直驻留在内存中，为后续对该servlet的请求服务</span><br><span class="line"> * 每次请求此servlet都会造成方法的执行</span><br><span class="line"> * 知道服务器的关闭，或者web应用的移除、销毁servlet的销毁</span><br><span class="line"> * 销毁之前又会调用</span><br><span class="line"> * */</span><br><span class="line">public class Servlet01 implements Servlet &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 初始化的方法</span><br><span class="line">     * servlet容器在初始化servlet后立即执行的方法，进行初始化的操作</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(&quot;this is servlet01&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 就在这个里面进行接收，</span><br><span class="line">     * 业务处理的方法</span><br><span class="line">     * 每当有请求都会访问此方法，</span><br><span class="line">     * 接受代表请求的request的对象</span><br><span class="line">     * 代表相应的rsponse对象</span><br><span class="line">     * 在请求中获取数据 在响应中写出数据</span><br><span class="line">     * 可以在此方法中处理业务逻辑</span><br><span class="line">     *</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line"> * 销毁方法</span><br><span class="line"> * 在servlet对象在销毁的时候之前会调用这个方法</span><br><span class="line"> * */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;GG&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet第二种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建servlet的第二种方式</span><br><span class="line"> * 继承</span><br><span class="line"> * **/</span><br><span class="line">public class Servlet02 extends GenericServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Servlet02~~~~service~~~&quot;);</span><br><span class="line">        servletResponse.getWriter().write(new Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet第三种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建servlet的第三种方式</span><br><span class="line"> * 也是继承，但是需要进行重写方法</span><br><span class="line"> * **/</span><br><span class="line">public class Servlet03 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到GET请求，时间：&quot;+new Date());</span><br><span class="line">        //输出流</span><br><span class="line">        resp.getWriter().write(new Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个可以通过基本路径后面添加<url-pattern>里面的路径，进行使用。Servlet使用起来让我感觉和我使用的TCP里面的WebSocket时很像，主要的函数都是在开始前先调用一个方法，然后是每次访问都执行一个方法，还有就是结束销毁前进行一个方法。、</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="JSP的使用，注册页面的实现，页面的引用"><a href="#JSP的使用，注册页面的实现，页面的引用" class="headerlink" title="JSP的使用，注册页面的实现，页面的引用"></a>JSP的使用，注册页面的实现，页面的引用</h3><p>先是将css和img里面要用到的css格式和图片进行导入，以及head头标签、foot尾部标签、index主页、rigis注册页面的资源导入。</p><p>然后就是在index.jsp文件显示头部标签、尾部标签jsp文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入头部 --&gt;</span><br><span class="line">&lt;%@include file=&quot;_head.jsp&quot;%&gt;</span><br><span class="line">&lt;!-- 引入尾部 --&gt;</span><br><span class="line">&lt;%@include file=&quot;_foot.jsp&quot;%&gt;</span><br></pre></td></tr></table></figure><p>jsp文件其实就相当于servlet一样，可以在里面写入java代码，原理就和上面一样用一个&lt;%@ %&gt;的固定格式，当然也可以进行html的编写。</p><p>显然表单的检验，需要前端和后端两处进行验证，前端的验证是用来提醒用户、增强用户的体验。后端的验证是对于提交表单后的安全性验证，因为要避免恶意用户通过URl的方式直接在路径里面进行提交，那样的方式会避开前端的验证，所以后端的验证主要是对于安全性的考虑。</p><h3 id="先优化前端的代码，增强交互感觉"><a href="#先优化前端的代码，增强交互感觉" class="headerlink" title="先优化前端的代码，增强交互感觉"></a>先优化前端的代码，增强交互感觉</h3><p><b>先实现当用户提交信息的时候，对注册表单里面的数据进行非空的校验。</b></p><p>那么我们首先就要对表单提交后进行绑定事件，action里面是对应的servlet的，method里面是表单提交的方式，onsubmit里面就是表单提交在前端绑定的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;servlet/RegistServlet&quot; method=&quot;POST&quot; onsubmit=&quot;return checkForm()&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后就是进行checkForm前端方法的创建，通过script的便签和function创建函数。<br>函数里面要进行对表单数据非空判断，又因为我们的前端页面里面没有id字段只有name字段，那么就通过document.getElementsByName[0].value来拿到数据，var创建对象进行接收。<br>接收完数据又要对属性进行非空判断，使用if进行判断，判断完成后，如果通过弹窗提醒用户错误，那么就使用alert函数。<br>当然这样在多数据的表单里面太过于繁琐，所以我们可以先在新建一个空值的前端标签,里面进行一些设置，字体红色：style&#x3D;”color: red”这样方便用户直观的了解是错误填写提示，当然我们后面要对这个空标签赋值，那么我们需要一个唯一id进行命名，用于后面赋值：id&#x3D;”username_msg”格式为对应的输入栏的name值加上_msg，方便后期调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color: red&quot; id=&quot;username_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;color:red&quot; id=&quot;password_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;color:red&quot; id=&quot;password2_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">······</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们就不要用上面的弹窗提醒了，使用复制的形式进行页面显示报错信息提醒：document.getElementById(“username_msg”).innerText”&#x3D;用户名不能为空”，通过id的方式进行查找然后innerText进行附上需要的提示信息。代码如下面的注释里面的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class="line">function checkForm() &#123;</span><br><span class="line">    //拿到name是username的值</span><br><span class="line">    var username = document.getElementsByName(&quot;username&quot;)[0].value;</span><br><span class="line">    if (username == null || username==&quot;&quot;)&#123;</span><br><span class="line">        //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">        // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">        setMsg(&quot;username&quot;,&quot;用户名不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var password = document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    if (password == null || password==&quot;&quot;)&#123;</span><br><span class="line">        //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">        // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">        setMsg(&quot;username&quot;,&quot;密码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    ······</span><br><span class="line">    ······</span><br><span class="line">    return false;//不提交是因为我们的业务并没有做完</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之所以将他注释，是因为如果这样写法的话会非常多重复操作，造成代码的繁琐，那么我们就使用java的包装思想，进行相同代码的包装。那么应该知道我要做什么了吧，我们再创建一个setMsg函数进行获取显示的错误信息的标签操作，既然要获取对应的标签，我们需要先提供，本来的name，还有报错信息,具体方法就是上面的包装document.getElementById(id+”_msg”).innerText&#x3D;msg。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//封装的方法，用来获取某一篮对应要显示的错误信息</span><br><span class="line">    function setMsg(id,msg) &#123;</span><br><span class="line">        //将需要显示的错误信息进行显示</span><br><span class="line">        document.getElementById(id+&quot;_msg&quot;).innerText=msg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们进行了包装，但是我们还是需要进行var的创建、判断是否为空，不如我们在进行包装，判断非空交给另一个函数，我们只需要交给它name，如果错误要显示的错误信息就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function checkNull(name,msg)&#123;</span><br><span class="line">    var v=document.getElementsByName(name)[0].value;</span><br><span class="line">    if(v == null || v==&quot;&quot;)&#123;</span><br><span class="line">        //报错</span><br><span class="line">        setMsg(name,msg)</span><br><span class="line">        //到达这里说明等于空或者null，所以要返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //说明不为空或null</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们主函数就只需要传name和如果错误要显示的错误信息，但是我们如何判断其中都是T（去提交）还是其中有F（不让提交）呢？这时候我们使用递归的思想，创建一个canSub，开始我们给他true，后面的进行“与”的判断，T+T&#x3D;T，T+F&#x3D;F这样我们就实现了上面的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function checkForm() &#123;</span><br><span class="line">    // //拿到name是username的值</span><br><span class="line">    // var username = document.getElementsByName(&quot;username&quot;)[0].value;</span><br><span class="line">    // if (username == null || username==&quot;&quot;)&#123;</span><br><span class="line">    //      //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">    //     // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">    //     setMsg(&quot;username&quot;,&quot;用户名不能为空&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">    //</span><br><span class="line">    // var password = document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    // if (password == null || password==&quot;&quot;)&#123;</span><br><span class="line">    //     //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">    //     // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">    //     setMsg(&quot;username&quot;,&quot;密码不能为空&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    //用递归、与门的思想进行快速判断是否正确</span><br><span class="line">    //初始化一个“T”</span><br><span class="line">    var canSub=true;</span><br><span class="line">    //开始递归，从判断用户名开始，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;username&quot;,&quot;用户名不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    // checkNull(&quot;username&quot;,&quot;用户名不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断密码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;password&quot;,&quot;密码不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;password&quot;,&quot;密码不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认密码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;password2&quot;,&quot;确认密码不能为空&quot;)&amp;&amp; canSub;</span><br><span class="line">    //继续递归，开始判断确认名称，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;nickname&quot;,&quot;名称不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;nickname&quot;,&quot;名称不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认邮箱，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;email&quot;,&quot;邮箱不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;email&quot;,&quot;邮箱不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认验证码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;valistr&quot;,&quot;验证码不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;valistr&quot;,&quot;验证码不能会空&quot;)</span><br><span class="line"></span><br><span class="line">    //密码一致校验</span><br><span class="line">    var psw1=document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    var psw2=document.getElementsByName(&quot;password2&quot;)[0].value;</span><br><span class="line">    if(psw1!=null &amp;&amp; psw1!=&quot;&quot;&amp;&amp;psw2!=null &amp;&amp; psw2!=&quot;&quot;&amp;&amp; psw1!=psw2)&#123;</span><br><span class="line">        setMsg(&quot;password2&quot;,&quot;两次密码不一致&quot;)</span><br><span class="line">        canSub=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //邮箱格式的校验</span><br><span class="line">    var email=document.getElementsByName(&quot;email&quot;)[0].value;</span><br><span class="line">    if(email!=null &amp;&amp; email!=&quot;&quot; &amp;&amp; !/^\w+@\w+(\.\w+)+$/.test(email))&#123;</span><br><span class="line">        setMsg(&quot;email&quot;,&quot;邮箱的格式不正确&quot;)//报错</span><br><span class="line">        canSub=false;//结束提交</span><br><span class="line">    &#125;</span><br><span class="line">    return canSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们还在主函数里面进行了两次密码的一致性判断，还有邮箱格式的判断，原理一样只是邮箱用到了“&#x2F;^\w+@\w+(.\w+)+$&#x2F;.test(email)”的<b>正则表达式</b>的判断。</p><p>现在我们的提交表单后的判断就成功了，但是在提交表单前面我们没有提示，这样用户在第一次的使用就会繁琐。我们现在进行表单提交前填写信息时的判断操作。</p><p><b>表单提交前填写信息时的判断：</b></p><p>我们要使用到onblur，这个作用就是当鼠标的焦点在这个标签移除时进行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkNull(&#x27;username&#x27;,&#x27;用户名不能为空&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>那么我们的自动提示就完成了，但是会有bug，因为我们没有考虑到刷新的问题，当用户已经收到一次错误信息后，下一次改正时，我们只是不再发送消息，并没有清除上一次的消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function checkNull(name,msg) &#123;</span><br><span class="line">    //清空每一次的错误消息</span><br><span class="line">    setMsg(name,&quot;&quot;)</span><br><span class="line">    var v=document.getElementsByName(name)[0].value;</span><br><span class="line">    if(v == null || v == &quot;&quot;)&#123;</span><br><span class="line">        setMsg(name,msg)</span><br><span class="line">        return false;//走到这里面就说明有空的,就返回false</span><br><span class="line">    &#125;</span><br><span class="line">    return  true;//进不去if就说明没有问题,返回true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后熟悉一下servlet的请求获取方法,getRequestURL() 获取请求地址,getQueryString() 获取请求的参数部分,getRemoteAddr() 获取客户机ip,getMethod() 获取请求的方式,getContextPath() 获取应用名称.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**  熟悉</span><br><span class="line"> * request:代表http请求的对象</span><br><span class="line"> * 功能1:获取客户机相关的信息</span><br><span class="line"> * getRequestURL() 获取请求地址</span><br><span class="line"> * getQueryString() 获取请求的参数部分</span><br><span class="line"> * getRemoteAddr() 获取客户机ip</span><br><span class="line"> * getMethod() 获取请求的方式</span><br><span class="line"> * getContextPath() 获取应用名称</span><br><span class="line"> */</span><br><span class="line">public class MyServlet01 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //请求地址</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        //请求资源路径</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        //获取请求的参数部门</span><br><span class="line">        String qs = request.getQueryString();</span><br><span class="line">        System.out.println(qs);</span><br><span class="line">        //获取客户机的ip</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        System.out.println(ip);</span><br><span class="line">        //获取请求方式</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        //应用名称</span><br><span class="line">        String cp = request.getContextPath();</span><br><span class="line">        System.out.println(cp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面的还有另一种方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**了解</span><br><span class="line"> * request功能2:获取请求头信息</span><br><span class="line"> * String getHeader(String var1); 接收请求头名字,返回请求值</span><br><span class="line"> * Enumeration&lt;String&gt; getHeaders(String var1); Enumeration是一个枚举对象,可以遍历,也就是说请求头中可能有多个一样的请求头</span><br><span class="line"> * Enumeration&lt;String&gt; getHeaderNames(); 获取所有请求头的名字的枚举</span><br><span class="line"> */</span><br><span class="line">public class MyServlet02 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String host = request.getHeader(&quot;host&quot;);</span><br><span class="line">        System.out.println(host);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; headers = request.getHeaders(&quot;User-Agent&quot;);</span><br><span class="line">        while (headers.hasMoreElements())&#123;</span><br><span class="line">            String v = headers.nextElement();</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">        //获取所有请求参数的名字</span><br><span class="line">        Enumeration&lt;String&gt; names = request.getHeaderNames();</span><br><span class="line">        while (names.hasMoreElements())&#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            String value = request.getHeader(name);</span><br><span class="line">            System.out.println(name+&quot;:&quot;+value);</span><br><span class="line">        &#125;</span><br><span class="line">        //或者整型类型的请求头信息</span><br><span class="line">        int i = request.getIntHeader(&quot;Upgrade-Insecure-Requests&quot;);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        long mydate = request.getDateHeader(&quot;mydate&quot;);</span><br><span class="line">        System.out.println(mydate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>当然需要掌握的是下面常用的方法，在此方法里面还解决了，在<br>post提交时出现中文乱码的问题因为get请求里面，请求参数是在【地址】之后进行传输的，那么get请求就会在Tomcat里面的server.xml里面的配置进行解码，默认utf-8，post请求实在【实体内容】里面进行传输的，但是每个浏览器有不同的加密方式，Tomcat默认对实体内容解码方式是通过IS08859-1。所以要加上request.setCharacterEncoding(“utf-8”)来解决中文乱码的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 掌握</span><br><span class="line"> * request的功能3:获取请求的参数</span><br><span class="line"> */</span><br><span class="line">public class MyServlet03 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //获取指定名称的请求参数的值</span><br><span class="line">        String uname = request.getParameter(&quot;uname&quot;);</span><br><span class="line">        System.out.println(uname);</span><br><span class="line">        //获取指定名称请求参数的值们</span><br><span class="line">        String[] likes = request.getParameterValues(&quot;like&quot;);</span><br><span class="line">        System.out.println(Arrays.asList(likes));</span><br><span class="line">        //获取所有请求参数的名字</span><br><span class="line">        Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">        while (names.hasMoreElements())&#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            String value = request.getParameter(name);</span><br><span class="line">            System.out.println(name+&quot;:&quot;+value);</span><br><span class="line">        &#125;</span><br><span class="line">        //获取所有请求参数组成的map</span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();//自动封装对象的时候用</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        //get请求里面，请求参数是在【地址】之后进行传输的，</span><br><span class="line">        //那么get请求就会在Tomcat里面的server.xml里面的配置进行解码，默认utf-8</span><br><span class="line"></span><br><span class="line">        //post请求实在【实体内容】里面进行传输的，但是每个浏览器有不同的加密方式，</span><br><span class="line">        //Tomcat默认对实体内容解码方式是通过IS08859-1</span><br><span class="line">        //请求参数乱码解决</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        String uname1 = request.getParameter(&quot;uname&quot;);</span><br><span class="line">        String uaddr1 = request.getParameter(&quot;uaddr&quot;);</span><br><span class="line">        System.out.println(uname1+&quot;==&quot;+uaddr1);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //super就是调用Tomcat帮我们写好的，Tonmcat就是如果过你调用我的我给你抛一个错误的</span><br><span class="line">        this.doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet还有重要的特点就是servlet之间的跳转<b>请求跳转</b></p><p>首先是最简单的servlet和servlet的跳转，在这个过程中浏览器的地址不会发生变化，当然servlet不只于在两个之间跳转，可以多个servlet之间进行跳转，但是不可以循环跳转（1到2，2不可以再回到1），并且再转发的时候只有最后的一个servlet才可以进行资源的对外输出，其他中间的servlet如果输出都会在转发时被清空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 请求转发:服务器内部的资源跳转</span><br><span class="line"> * 一次请求一次响应</span><br><span class="line"> * 整个过程中是同一个request</span><br><span class="line"> * 浏览器的地址不会发生变化</span><br><span class="line"> * 可以多重转发,但是不能循环转发</span><br><span class="line"> * 转发过程中只有最后一个资源可以对外输出数据,其他资源的输出都会在转发时清空</span><br><span class="line"> */</span><br><span class="line">public class MyServlet04 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet04~~~~~&quot;);</span><br><span class="line">        //发起请求转发</span><br><span class="line">        request.getRequestDispatcher(&quot;/servlet/MyServlet05&quot;).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然可以servlet之间的请求转发可以做到，那么数据的传输也要有所了解，其中对request的域对象的三个特征：生命周期、作用范围、主要功能需要进行细致了解。对于域对象的生命周期；就是再requset对象的创建到request的对象销毁。作用范围：再一次请求范围之内有效。主要的功能：再一个请求内进行（转发和包含、共享）数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//向request域中写入数据</span><br><span class="line">    request.setAttribute(&quot;name&quot;,&quot;apple&quot;);</span><br><span class="line">//从request中获取数据</span><br><span class="line">    String name = (String) request.getAttribute(&quot;name&quot;);</span><br><span class="line">//向response里面写入状态码</span><br><span class="line">    response.setStatus(403);</span><br><span class="line">//向response创建响应头</span><br><span class="line">    response.setHeader(&quot;asd&quot;,&quot;123&quot;);</span><br><span class="line">//向response写入响应头</span><br><span class="line">    response.addHeader(&quot;asd&quot;,&quot;456&quot;);</span><br></pre></td></tr></table></figure><p>当然技术需要和业务进行结合，现在servlet的数据传递进行拓展：</p><p><b>servlet的定时刷新：</b>就像支付宝的沙箱支付里面的回显操作，会先在一个页面里面进行显示提示文字，后面跟着几秒后进行刷新、跳转到XX界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.getWriter().write(&quot;恭喜注册成功,3秒后跳转首页&quot;);</span><br><span class="line">response.setHeader(&quot;refresh&quot;,&quot;3;url=&quot;+request.getContextPath()+&quot;/index.jsp&quot;);</span><br></pre></td></tr></table></figure><p><b>servlect的重定向：</b>重定向出现的业务是：当我们进行表单提交后，如果直接在当前servlet类里面的业务进行页面的跳转，那么如果用户此时刷新页面，那么就会显示是否进行重新提交表单数据，这样来说是不安全的。那么重定向的实现业务就是<b>解决刷新页面导致表单的重新提交</b>。显示解释重定向的原理：重定向就相当于是对一条servlet进行两次的请求和两次响应，当响应服务开始的时候，和之前一样携带着数据进行传递过来然后对数据进行逻辑判断，后面就不一样了，按以前的逻辑，我们要返回用户后面要跳转页面的URL，但是现在“重定向”我们需要进行返回一个302和一个location交给浏览器，这时候浏览器会根据location再进行一个访问，我们接收后再进行之后的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//基础代码</span><br><span class="line">response.setStatus(403);</span><br><span class="line">response.setHeader(&quot;location&quot;,request.getContextPath()+&quot;/index.jsp&quot;);</span><br><span class="line">//下面是简便的写法</span><br><span class="line">response.sendRedirect(request.getContextPath()+&quot;/index.jsp&quot;);</span><br></pre></td></tr></table></figure><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="验证码的制作"><a href="#验证码的制作" class="headerlink" title="验证码的制作"></a>验证码的制作</h3><p>先是昨天的重定向时页面显示时中文乱码的问题（页面上面只要有？？？？）：首先是为什么都是？？？，因为我们在编码的时候没有指定要进行的编码方式，所以当浏览器解码的时候根本识别不出来是什么所以就只有问号。此前我们只进行过传入流的解码方式自定义（utf-8），还没有及逆行传出流的编码方式自定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br></pre></td></tr></table></figure><p>验证码先是使用老师提供的utile工具类，里面包装了不同字体，随机颜色，6个干扰线，-45到45的旋转，还有一个get方法出验证码校验文本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.utile;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.Font;</span><br><span class="line">import java.awt.Graphics2D;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line">/**</span><br><span class="line"> * 动态生成图片</span><br><span class="line"> */</span><br><span class="line">public class VerifyCode &#123;</span><br><span class="line">// &#123;&quot;宋体&quot;, &quot;华文楷体&quot;, &quot;黑体&quot;, &quot;华文新魏&quot;, &quot;华文隶书&quot;, &quot;微软雅黑&quot;, &quot;楷体_GB2312&quot;&#125;</span><br><span class="line">private static String[] fontNames = &#123; &quot;宋体&quot;, &quot;华文楷体&quot;, &quot;黑体&quot;, &quot;微软雅黑&quot;,  &quot;楷体_GB2312&quot; &#125;;</span><br><span class="line">// 可选字符</span><br><span class="line">//&quot;23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ&quot;;</span><br><span class="line">private static String codes = &quot;23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ&quot;;</span><br><span class="line">// 背景色</span><br><span class="line">private Color bgColor = new Color(255, 255, 255);</span><br><span class="line">// 基数(一个文字所占的空间大小)</span><br><span class="line">private int base = 30;</span><br><span class="line">// 图像宽度</span><br><span class="line">private int width = base * 4;</span><br><span class="line">// 图像高度</span><br><span class="line">private int height = base;</span><br><span class="line">// 文字个数</span><br><span class="line">private int len = 4;</span><br><span class="line">// 设置字体大小</span><br><span class="line">private int fontSize = 22;</span><br><span class="line">// 验证码上的文本</span><br><span class="line">private String text;</span><br><span class="line"></span><br><span class="line">private BufferedImage img = null;</span><br><span class="line">private Graphics2D g2 = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生成验证码图片</span><br><span class="line"> */</span><br><span class="line">public void drawImage(OutputStream outputStream) &#123;</span><br><span class="line">// 1.创建图片缓冲区对象, 并设置宽高和图像类型</span><br><span class="line">img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">// 2.得到绘制环境</span><br><span class="line">g2 = (Graphics2D) img.getGraphics();</span><br><span class="line">// 3.开始画图</span><br><span class="line">// 设置背景色</span><br><span class="line">g2.setColor(bgColor);</span><br><span class="line">g2.fillRect(0, 0, width, height);</span><br><span class="line"></span><br><span class="line">StringBuffer sb = new StringBuffer();// 用来装载验证码上的文本</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">// 设置画笔颜色 -- 随机</span><br><span class="line">// g2.setColor(new Color(255, 0, 0));</span><br><span class="line">g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150),getRandom(0, 150)));</span><br><span class="line"></span><br><span class="line">// 设置字体</span><br><span class="line">g2.setFont(new Font(fontNames[getRandom(0, fontNames.length)], Font.BOLD, fontSize));</span><br><span class="line"></span><br><span class="line">// 旋转文字(-45~+45)</span><br><span class="line">int theta = getRandom(-45, 45);</span><br><span class="line">g2.rotate(theta * Math.PI / 180, 7 + i * base, height - 8);</span><br><span class="line"></span><br><span class="line">// 写字</span><br><span class="line">String code = codes.charAt(getRandom(0, codes.length())) + &quot;&quot;;</span><br><span class="line">g2.drawString(code, 7 + i * base, height - 8);</span><br><span class="line">sb.append(code);</span><br><span class="line">g2.rotate(-theta * Math.PI / 180, 7 + i * base, height - 8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.text = sb.toString();</span><br><span class="line"></span><br><span class="line">// 画干扰线</span><br><span class="line">for (int i = 0; i &lt; len + 2; i++) &#123;</span><br><span class="line">// 设置画笔颜色 -- 随机</span><br><span class="line">// g2.setColor(new Color(255, 0, 0));</span><br><span class="line">g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150),</span><br><span class="line">getRandom(0, 150)));</span><br><span class="line">g2.drawLine(getRandom(0, 120), getRandom(0, 30), getRandom(0, 120),</span><br><span class="line">getRandom(0, 30));</span><br><span class="line">&#125;</span><br><span class="line">//TODO:</span><br><span class="line">g2.setColor(Color.GRAY);</span><br><span class="line">g2.drawRect(0, 0, this.width-1, this.height-1);</span><br><span class="line">// 4.保存图片到指定的输出流</span><br><span class="line">try &#123;</span><br><span class="line">ImageIO.write(this.img, &quot;JPEG&quot;, outputStream);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">// 5.释放资源</span><br><span class="line">g2.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取验证码字符串</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public String getCode() &#123;</span><br><span class="line">return this.text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 生成随机数的方法</span><br><span class="line"> */</span><br><span class="line">private static int getRandom(int start, int end) &#123;</span><br><span class="line">Random random = new Random();</span><br><span class="line">return random.nextInt(end - start) + start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*public static void main(String[] args) throws Exception &#123;</span><br><span class="line">VerifyCode vc = new VerifyCode();</span><br><span class="line">vc.drawImage(new FileOutputStream(&quot;f:/vc.jpg&quot;));</span><br><span class="line">System.out.println(&quot;执行成功~!&quot;);</span><br><span class="line">&#125;*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么需要再建一个servlet进行验证码点击的创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line">import cn.tedu.utile.VerifyCode;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class ServletCode extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //禁止浏览器的缓存,-1代表禁止缓存，三个都是禁止浏览器的缓存</span><br><span class="line">        response.setIntHeader(&quot;Expires&quot;,-1);</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);</span><br><span class="line">        response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);</span><br><span class="line">        //创建验证码对象</span><br><span class="line">        VerifyCode vc=new VerifyCode();</span><br><span class="line">        //生成验证码</span><br><span class="line">        vc.drawImage(response.getOutputStream());</span><br><span class="line">        //获取验证码</span><br><span class="line">        String code=vc.getCode();</span><br><span class="line">        //输出</span><br><span class="line">        System.out.println(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时前端也需要在验证码标签上面绑定点击事件，又因为地址发生变化的时候才会重新进行请求所以需要加上时间戳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//函数的创建</span><br><span class="line">function changeImg(imgObj)&#123;</span><br><span class="line">    //地址发生变化的时候会重新进行请求</span><br><span class="line">    imgObj.src=&quot;&lt;%=request.getContextPath()%&gt;/servlet/ServletCode?time=&quot;+new Date().getTime();</span><br><span class="line">&#125;</span><br><span class="line">//事件的绑定</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td class=&quot;tds&quot;&gt;验证码：&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;valistr&quot;&gt;</span><br><span class="line">        &lt;img id=&quot;yzm_img&quot; onclick=&quot;changeImg(this)&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/servlet/ServletCode&quot; style=&quot;cursor: pointer&quot;/&gt;</span><br><span class="line">        &lt;span style=&quot;color: red&quot; id=&quot;valistr_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><h3 id="ajax的异步使用，优化前端"><a href="#ajax的异步使用，优化前端" class="headerlink" title="ajax的异步使用，优化前端"></a>ajax的异步使用，优化前端</h3><p>使用Ajax的话需要先在项目里面进行引入jquery.js的文件，位置为在web下面里面的js下面。AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX &#x3D; 异步 JavaScript 和 XML。Ajax的主要是在异步上面，用户在进行操作的时候就可以进行需要的服务，不会出现等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function checkUsername()&#123;</span><br><span class="line">    var isNoNull=checkNull(&quot;username&quot;,&quot;用户不为空&quot;)</span><br><span class="line">    if (isNoNull)&#123;</span><br><span class="line">        //不为空时</span><br><span class="line">        //检验存不存在</span><br><span class="line">        // $.ajax(&#123;</span><br><span class="line">        //</span><br><span class="line">        // &#125;)</span><br><span class="line">        var username=document.getElementsByName(&quot;username&quot;).value;</span><br><span class="line">        $.get(&quot;&lt;%= request.getContextPath()%&gt;/servlet/AjaxHasUserNameServlet&quot;,&#123;&quot;username&quot;:username&#125;,function (data)&#123;</span><br><span class="line">            alert(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">//AjaxHasUserEmailServlet</span><br><span class="line">public class AjaxHasUserEmailServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //解决乱码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        //获取请求参数</span><br><span class="line">        String useremail = request.getParameter(&quot;useremail&quot;);</span><br><span class="line">        System.out.println(useremail);</span><br><span class="line">        //检查邮箱是否存在</span><br><span class="line">        Connection conn=null;</span><br><span class="line">        PreparedStatement ps=null;</span><br><span class="line">        ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            conn= JDBCUtiles.getConn();</span><br><span class="line">            ps=conn.prepareStatement(&quot;select * from user where email=?&quot;);</span><br><span class="line">            ps.setString(1,useremail);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                //输出结果</span><br><span class="line">                response.getWriter().write(&quot;邮箱已存在&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                response.getWriter().write(&quot;邮箱可用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtiles.close(conn,ps,rs);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        //response.getWriter().write(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">//AjaxHasUserEmailServlet</span><br><span class="line">public class AjaxHasUserNameServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //解决乱码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        //获取请求参数</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        //检查用户名是否存在</span><br><span class="line">        Connection conn=null;</span><br><span class="line">        PreparedStatement ps=null;</span><br><span class="line">        ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            conn= JDBCUtiles.getConn();</span><br><span class="line">            ps=conn.prepareStatement(&quot;select * from user where username=?&quot;);</span><br><span class="line">            ps.setString(1,username);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                //输出结果</span><br><span class="line">                response.getWriter().write(&quot;用户名已存在&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                response.getWriter().write(&quot;用户名可用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtiles.close(conn,ps,rs);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        //response.getWriter().write(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class AjaxHasUserNicknameServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //解决乱码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        //获取请求参数</span><br><span class="line">        String usernickname = request.getParameter(&quot;usernickname&quot;);</span><br><span class="line">        System.out.println(usernickname);</span><br><span class="line">        //检查邮箱是否存在</span><br><span class="line">        Connection conn=null;</span><br><span class="line">        PreparedStatement ps=null;</span><br><span class="line">        ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            conn= JDBCUtiles.getConn();</span><br><span class="line">            ps=conn.prepareStatement(&quot;select * from user where nickname=?&quot;);</span><br><span class="line">            ps.setString(1,usernickname);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                //输出结果</span><br><span class="line">                response.getWriter().write(&quot;昵称已存在&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                response.getWriter().write(&quot;昵称可用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtiles.close(conn,ps,rs);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        //response.getWriter().write(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>会话技术:实现登录</b>因为http的请求是一种无状态的请求，所以每次的请求服务器并不知道是谁的，这时候我们就要用到了会话技术cookie和session了，cookie是将信息存储到浏览器，session是将信息交给服务器，这里我们用的是session，session也是request的域之一。<br>request的域其中的最基层的。就是request它只可以在一次访问请求之中进行数据的传递，<br>还有一个全域的，就是servletContext，它可以全部请求的数据访问，但是它的作用域导致其他的用户也会收到这个请求里面的东西。<br>这时候我们就需要进行session的会话技术了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将code存储到session域中</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;valistr&quot;, code);</span><br><span class="line"></span><br><span class="line">// 删除原有的session</span><br><span class="line">request.getSession().invalidate();// 删除session</span><br><span class="line">// 回到登录页</span><br><span class="line">response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);</span><br><span class="line"></span><br><span class="line"> // 验证成功，删除session中存储的验证码</span><br><span class="line">request.getSession().removeAttribute(&quot;valistr&quot;);</span><br></pre></td></tr></table></figure><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h3 id="登陆页面的优化，添加动态的标签动态，"><a href="#登陆页面的优化，添加动态的标签动态，" class="headerlink" title="登陆页面的优化，添加动态的标签动态，"></a>登陆页面的优化，添加动态的标签动态，</h3><p>原理和上面的注册页面动态提示一样，不多做解释。</p><h3 id="记住用户"><a href="#记住用户" class="headerlink" title="记住用户"></a>记住用户</h3><p>就是cookie的使用，将用户名写进cookie里面，然后前端页面进行cookie遍历，遍历到需要的就进行获取显示，当然要设置中文编码，一个是作用域的设置，另一个是cookie的保留时间的设置，cookie的删除，直接将cookie进行保存时间为0的设置就行。</p><p>当然还要考虑，如果当用户第一次点击记住账号，第二次取消了记住密码，那么要在服务里面进行cookie的删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // 是否记住用户名</span><br><span class="line">if (&quot;true&quot;.equals(remname)) &#123;</span><br><span class="line">    // 记住，添加cookie</span><br><span class="line">    Cookie cookie = new Cookie(&quot;remname&quot;, URLEncoder.encode(username, &quot;utf-8&quot;));// 编码传输</span><br><span class="line">    cookie.setPath(request.getContextPath() + &quot;/login.jsp&quot;);</span><br><span class="line">    cookie.setMaxAge(60 * 60 * 24 * 14);// 十四天有效</span><br><span class="line">    response.addCookie(cookie);// cookie保存到本地</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 取消记住，删除cookie</span><br><span class="line">    Cookie cookie = new Cookie(&quot;remname&quot;, &quot;&quot;);</span><br><span class="line">    cookie.setPath(request.getContextPath() + &quot;/login.jsp&quot;);</span><br><span class="line">    cookie.setMaxAge(0);// 立即失效</span><br><span class="line">    response.addCookie(cookie);// cookie保存到本地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Cookie[] cookies = request.getCookies();</span><br><span class="line">    Cookie findC = null;</span><br><span class="line">    Cookie unameC = null;</span><br><span class="line">    Cookie pwdC = null;</span><br><span class="line">    if (cookies != null) &#123;</span><br><span class="line">        for (Cookie c : cookies) &#123;</span><br><span class="line">            if (&quot;remname&quot;.equals(c.getName())) &#123;</span><br><span class="line">                findC = c;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;username&quot;.equals(c.getName())) &#123;</span><br><span class="line">                unameC = c;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;password&quot;.equals(c.getName())) &#123;</span><br><span class="line">                pwdC = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String username = &quot;&quot;;</span><br><span class="line">    if (findC != null) &#123;        // 接收、解码</span><br><span class="line">        username = URLDecoder.decode(findC.getValue(), &quot;utf-8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><p>无学习，自己做东西</p><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><p>答辩</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
