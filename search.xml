<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jwt细致了解</title>
      <link href="/2023/10/26/jwt%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3/"/>
      <url>/2023/10/26/jwt%E8%AF%A6%E7%BB%86%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT是什么？基本组成是什么？"><a href="#JWT是什么？基本组成是什么？" class="headerlink" title="JWT是什么？基本组成是什么？"></a>JWT是什么？基本组成是什么？</h2><p>JWT是JSON Web Token的缩写。它是一种用于安全地在两个实体之间传递信息的开放标准（RFC 7519）。这些信息可以被验证和信任，因为它是经过数字签名的。JWT通常用于在网络应用程序和服务之间传递身份验证信息和声明信息，确保数据在传输过程中不被篡改。</p><p>JWT是一个由三部分组成的字符串，这三部分之间用点（.）分隔开来：</p><ol><li><p><strong>Header（头部）</strong>：头部通常由两部分组成，第一部分是令牌的类型，通常是JWT，第二部分是所使用的签名算法，例如HMAC SHA256或RSA。</p><p>示例头部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Payload（负载）</strong>：负载包含了要传输的声明信息。声明是关于实体（通常是用户）和其他数据的声明。有三种类型的声明：registered注册声明，public公共声明和private私有声明。</p></li></ol><ul><li><p>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</p></li><li><p>Public claims : 可以随意定义。</p></li><li><p>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</p><p> 示例负载：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;iat&quot;: 1516239022</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p><strong>Signature（签名）</strong>：签名是使用头部中指定的算法和密钥对头部和负载进行签名生成的，以确保数据的完整性和真实性。签名的作用是防止数据在传输过程中被篡改。</p><p>签名示例（使用HMAC SHA256算法）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><p>在JWT中Signature（签名）可以看出，Header和Payload都会先被转换成JSON格式，然后再进行Base64编码。Base64编码是一种将二进制数据转换成可打印字符的编码方式，它将二进制数据按照固定的规则转换成文本字符串，这样可以确保数据在传输过程中不会被损坏。</p><p>所以，JWT的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base64UrlEncode(Header) + &quot;.&quot; + Base64UrlEncode(Payload) + &quot;.&quot; + Signature</span><br></pre></td></tr></table></figure><p>因此，一个典型的JWT看起来是这个样子的：xxxxx.yyyyy.zzzzz，并且私密的信息最好加密后再放到JWT的payload或header中。</p><p><strong>官网直观图：</strong></p><p><img src="/img/image-20210407203818808.png" alt="image-20210407203818808"></p><h2 id="JSON-Web-Tokens是如何具体工作的"><a href="#JSON-Web-Tokens是如何具体工作的" class="headerlink" title="JSON Web Tokens是如何具体工作的"></a>JSON Web Tokens是如何具体工作的</h2><p>JWT（JSON Web Tokens）的工作方式可以分为三个主要步骤：创建（Signing）、传输（Transmission）、验证（Verification）。</p><h3 id="1-创建（Signing）"><a href="#1-创建（Signing）" class="headerlink" title="1. 创建（Signing）:"></a>1. 创建（Signing）:</h3><ol><li><p><strong>头部和负载生成</strong>：首先，创建一个包含所需声明的 JSON 对象，这个对象即为 JWT 的负载（Payload）。同时，创建一个头部（Header）对象，指定签名算法（比如 HMAC SHA256 或 RSA）和令牌类型（通常是JWT）。</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Header<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">Payload<span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1516239022</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>生成签名</strong>：将Base64Url编码后的头部和负载连接起来，并使用指定的密钥和算法生成签名。签名的作用是确保数据在传输过程中不被篡改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中，<code>base64UrlEncode()</code> 是Base64Url编码的函数，<code>secret</code> 是用于签名的密钥。</p></li><li><p><strong>生成JWT</strong>：将Base64Url编码后的头部、负载和签名用点（.）连接起来，形成最终的JWT字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base64UrlEncode(Header) + &quot;.&quot; + Base64UrlEncode(Payload) + &quot;.&quot; + Base64UrlEncode(Signature)</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-传输（Transmission）"><a href="#2-传输（Transmission）" class="headerlink" title="2. 传输（Transmission）:"></a>2. 传输（Transmission）:</h3><p>将生成的JWT字符串发送给接收者，通常通过HTTP头部信息或请求参数的形式传输。JWT通常放置在请求的Authorization头中（HTTP请求中的Authorization头部通常用于标识客户端请求的用户身份凭证），使用Bearer模式（Bearer模式是一种身份验证授权方式，它指示服务器请求中所携带的令牌（token）是JWT）。</p><p>示例如下：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;JWT&gt;</span><br></pre></td></tr></table></figure><p>   在这里，<code>&lt;JWT&gt;</code>代表实际的JSON Web Token。通过Bearer模式，服务器能够识别出请求中携带的身份凭证是JWT类型的令牌，并进行相应的验证和授权操作。</p><h3 id="3-验证（Verification）"><a href="#3-验证（Verification）" class="headerlink" title="3. 验证（Verification）:"></a>3. 验证（Verification）:</h3><p>接收者收到JWT后，可以按照以下步骤验证JWT的有效性：</p><ol><li><p><strong>解码JWT</strong>：接收者将JWT字符串按点（.）拆分为头部、负载和签名，并进行Base64Url解码，得到原始的头部和负载信息。</p></li><li><p><strong>验证签名</strong>：接收者使用相同的算法、密钥和头部中指定的签名算法验证签名的正确性。如果签名验证通过，表示JWT的发送者是可信的。</p></li><li><p><strong>验证声明</strong>：接收者验证负载中的声明，比如检查令牌是否过期（通过<code>exp</code>声明）、确认签发者的身份（通过<code>iss</code>声明）等。</p></li></ol><p>如果在解码、签名验证或声明验证的任何步骤中发现问题，JWT将被视为无效，接收者可以拒绝接受该令牌，确保应用程序的安全性。</p><h2 id="JSON-Web-Tokens的优点与缺点"><a href="#JSON-Web-Tokens的优点与缺点" class="headerlink" title="JSON Web Tokens的优点与缺点"></a>JSON Web Tokens的优点与缺点</h2><p>JSON Web Tokens（JWT）是一种在网络应用中广泛使用的身份验证和信息交换方式，它具有许多优点和一些限制。下面是JWT的优点和缺点：</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li><p><strong>轻量和简单</strong>：JWT是一种轻量级的数据交换格式，易于生成和解析。它的简单结构使得它在网络传输中非常高效。</p></li><li><p><strong>跨平台和跨语言</strong>：由于是基于JSON格式的标准，JWT可以在不同的平台和编程语言之间轻松传递和解析，提供了很好的跨平台互通性。</p></li><li><p><strong>无状态性（Stateless）</strong>：JWT是无状态的，服务器不需要在会话中保存用户的状态信息。所有的信息都被包含在JWT本  身中，这样可以减轻服务器的负担，提高了可伸缩性。如果JWT中包含了足够的必需数据，服务器可以减少对某些操作的数据库查询，因为它可以直接从JWT中获取所需信息，而无需查询数据库。这有助于提高性能。</p></li><li><p><strong>灵活性</strong>：JWT支持自定义声明，开发者可以根据需要在负载中包含任意信息，使得JWT非常灵活，可以用于各种场景。</p></li><li><p><strong>不依赖Cookie</strong>：JWT不依赖于浏览器的Cookie机制。当浏览器发起跨域请求时，如果请求中包含JWT，服务器可以验证JWT的有效性，并授权访问资源，而不受CORS的限制，因为JWT不被视为敏感的浏览器“凭证”。</p></li><li><p><strong>安全性</strong>：通过使用签名算法，JWT可以验证数据的完整性和真实性，确保信息在传输过程中不被篡改。这使得它成为一个相对安全的身份验证机制。</p></li><li><p><strong>分布式应用</strong>：由于JWT的特性，它非常适用于分布式系统，各个服务之间可以通过JWT进行身份验证和信息传递。</p></li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li><p><strong>无法撤销</strong>：一旦JWT被签发，就无法撤销或失效。即使在有效期内，如果用户的权限发生变化，服务器也无法立即撤销一个已签发的JWT。这个问题可以通过短有效期和额外的撤销机制来缓解。</p></li><li><p><strong>增加网络负担</strong>：由于每个请求都需要携带JWT，在网络传输中会增加一些额外的负担，尤其是在JWT较大时。</p></li><li><p><strong>敏感信息</strong>：尽管JWT的内容可以被加密，但是通常情况下，不应该在JWT中存储敏感信息，因为JWT可以被解码和读取。对于敏感信息，建议在服务器端进行处理。</p></li><li><p><strong>硬编码问题</strong>：如果JWT的密钥泄露，所有使用该密钥签发的JWT都会受到威胁。因此，密钥管理是使用JWT时需要特别注意的问题。</p></li></ol><p>综合考虑，JWT是一种强大的工具，但在使用时需要小心处理，特别是在处理敏感信息和密钥管理方面。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马头条</title>
      <link href="/2023/06/13/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1/"/>
      <url>/2023/06/13/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑马java面经总结</title>
      <link href="/2023/06/12/%E9%BB%91%E9%A9%ACjava%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/06/12/%E9%BB%91%E9%A9%ACjava%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="Redis的缓存问题"><a href="#Redis的缓存问题" class="headerlink" title="Redis的缓存问题"></a>Redis的缓存问题</h2><h3 id="Redis的穿透"><a href="#Redis的穿透" class="headerlink" title="Redis的穿透"></a>Redis的穿透</h3><p><b>Redis的穿透概念：</b>举个例子不陌生的例子：<b>网络攻击</b>，其中就可能是他人通过某些手段获取到了你的请求URL，然后用你的数据库<b>里面根本不存在的数据来疯狂访问你的项目</b>，又因为正常的项目都是在用户请求数据的时候先去Redis里面进行查询，查询不到了之后才会去数据库里面查询，数据库里面查询到之后会将数据放到Redis里面，这样用户下次的访问就可以在Redis里面进行快速的回应。这样就会发现黑客用大量的虚假数据进行访问时，就会都跳过Redis前往数据库进行查询，这样的话数据库的I&#x2F;O就会压力负载变大，当达到临界值的时候就会将数据库搞崩。这样就相当于<b>Redis被穿过去了直接将压力传递给了数据库</b>，所以这个问题就是Redis穿透问题。</p><p><b>Redis穿透问题的解决方法：</b></p><p><b>一：缓存空数据：</b>查询结果为空的时候仍把这个空数据进行缓存。<br>优点：简单。    缺点：消耗内存，可能会发生不一致的问题。</p><p><b>二：布隆过滤器</b><br>&amp;emsp; <b>运行原理：</b>比如在id查询时先通过查询布隆过滤器，如果不存在就直接返回，如果在布隆过滤器内存在才去Redis里面查询，（也就是在redis前查询前又加了一个过程），当然使用这种的话有一个关键的前提（缓存预热时还要对布隆过滤器进行预热）</p><p><b>布隆过滤器原理：</b>其实就是bitmap（位图）：一个以（bit）位为单位的数组，数组中每一个单位都只能存储0或1。预热时就是将一个一个值（id）进行多次hash函数后获取hash的值，然后将那个位置的值（hash后id）改成1。查询时就使用相同的hash函数进行获取hash值，判断hash值的位置是否位1，是就证明redis存在，不是则相反，当然这样的话肯定会存在误判（比如库里面只有1和2，hash后1对应的是1、3、5，2对应的是2、4、6，现在来了个3，hash后假如是：1、2、3，那么所有的值也是1，但是库里面却没有3的数据，这就是误判），所以布隆过滤器可以调整容错率。<br>优点：内存占用较小，没有多余的key。    缺点：存在误判的问题。</p><h3 id="Redis的击穿"><a href="#Redis的击穿" class="headerlink" title="Redis的击穿"></a>Redis的击穿</h3><p><b>Redis的击穿概念：</b>在现实使用中除了人为破坏当然还有<b>意外或者无意造成破坏</b>，其中就可能redis里面“碰巧”<b>出现一个数据过期后，同一时间大量数据进行访问</b>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又又又拉满了，当接近<b>“击穿电压”【临界值】</b>时数据库就会又被搞崩，所以这个问题就是Redis“击穿”问题【redis没有管理好“电压”，导致数据库“用电器”被击穿了】。</p><p><b>Redis击穿问题的解决方法：</b></p><p><b>一：添加互斥锁：</b>多个线程里面最先的那个先发现redis里面没有，申请互斥锁并成功，那么就去数据库查询，后面的线程虽然redis里面查询没有，但是因为申请不到互斥锁，就只能休眠一会，然后自动重新从头开始redis访问，当最前面的线程查询到数据库里面的数据，并且将数据写入缓存时，才释放互斥锁。<br>优点：强一致性。【不是绝对】    缺点：性能差【只有一个能拿到锁，其他都只能休眠，造成用户只能干等的局面】。  适用于银行金融，需要强一致性的场所。</p><p><b>二：逻辑过期</b>：其实就像萌新的我刚刚遇到这个问题，第一个想法就是<b>不设置过期时间</b>，但是这样的话redis里面的数据时效性就会被破坏，那么就<b>再添加一个字段为“保质期”</b>当后面程序拿到了这个数据，一分析居然是“过期的”就会去申请互斥锁，那么拿到互斥锁的那个线程就会，再多开一个新线程，新线程去数据库查询和写入缓存、释放锁操作。当然在这期间原本那个线程和后面申请不到互斥锁的线程就会带着过期的数据返回，不会盲目等待，可以先去干别。直到新线程重新写入缓存、修改逻辑、过期时间、后这个数据就可以使用了，再来进行访问。<br>优点：高可用性，性能也好。    缺点：一致性差。  适用于互联网这种高可用性的场所</p><h3 id="Redis的雪崩"><a href="#Redis的雪崩" class="headerlink" title="Redis的雪崩"></a>Redis的雪崩</h3><p><b>Redis的雪崩概念：</b>在实际使用redis时如果不规范，也会造成<b>意外或者无意</b>造成破坏，其中就可能redis里面“碰巧”<b >出现同一时间大量的缓存key同时失效或者redis宕机了</b>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又拉又满了，而导致的数据库的压力增大就是redis的雪崩。</p><p><b>Redis雪崩问题的解决方法：</b></p><p><b>一：给不同的key的TTl添加随机值：</b>从过期时间上面的更改。<br><b>二：利用Redis的集群提高服务的的可用性：</b>“哨兵模式”、“集群模式”从redis性能上面的更改。<br><b>三：给缓存业务添加降级限流策略：</b>使用“Nginx”、“spring cloud gateway”从业务上面进行更改。<br><b>四：给业务添加多级缓存：</b>“Guava”、“Caffeine”通过增加多级缓存。</p><h3 id="Redis的双写一致性"><a href="#Redis的双写一致性" class="headerlink" title="Redis的双写一致性"></a>Redis的双写一致性</h3><p>双写一致性其实就是：<b>如何保持redis和数据库的数据一致</b>。那么就是对数据库和缓存的数据更新处理。</p><p><b>双写一致性的方法：</b><br><b>一：延迟双删:</b><br>首先是为什么要进行延迟双删？因为如果只是数据库和redis的单次删除，那么无论如何处理（先删除数据库、先删除redis）都会导致数据的不一致导致脏读现象的出现。</p><p>先操作数据库再删除redis的话，理想的情况下是：当我们操作完数据库之后，并且将数据在redis里面删除，下一个线程查询不到redis里面的数据的时候，开始到数据库里面查询数据之后再写入redis里面，后面的的请求再在redis里面进行数据的获取。但是会出现一种情况就是当数据库被操作之前，redis里面的数据过期了或者被淘汰掉了，那么会有一个线程到数据库里面进行查询，这条线程查询到的是一个未被更新的数据，但是它还没有写入redis里面的时候我们进行了操作数据库和删除redis的操作，那么当我们结束后，读取到未被更新的数据的线程开始重新进行，将未被更新的数据写入redis里面，，导致之后出现脏读现象。<br>先删除redis后再操作数据库的话，理想情况下是：当我们删除数据和操作数据库之后，再来请求，发现reids里面没有数据，那么就会想数据库进行访问，然后再将数据库访问到的新数据写入到redis里面。但是会出现一种情况就是：当我们在删除redis数据完成之后，但是在书库操作之前，来了个线程，它先在redis里面查询发现没有数据，那么就会去数据库访问，但是我们还没有更新数据，就导致该线程查询到了未更新的数据，这是我们再进行是你出redis，操作数据库完成之后，查询到违背更新的数据的线程将数据返回并且还写入到redis里面，导致之后数据的脏读现象发生。</p><p>所以我们要避免脏读现象的出现最简单的就是“延迟双删”的操作，也和字面意思一样，当我们无论是先删除redis还是操作数据库，完成流程之后等一段时间再对reids进行二次删除，那么就不会再出现脏读的现象了。</p><p><b>二：分布式锁：</b><br>我们也可以进行加锁，首先是最简单的，无论是读还是写都要进行拿锁，拿到锁后才能进行数据对应的操作。（这样的话是强一致性，但是对于性能方面上是十分差的）</p><p>那么我们可以想一下redis里面的数据肯定是读多写少的数据，那么通过排他锁（读和写互斥）、共享锁（读读不互斥，写互斥）可以进一步提高性能。</p><p>当我们要进行读操作的时候进行添加共享锁，多个线程的读都不会影响，当进行写操作的时候添加一个排他锁，这样的话就读就无法进行，从而实现强一致性避免脏读，但是这样的话当我们进行写的时候读就无法进行，那么效率和性能还是很差的。是用在需要强一致性的场合才用。</p><p>当然除了强一致性的特殊场合，还有对一致性要求不高但是对性能要求高的场所，还有两种方案：</p><p><b>三：使用MQ：</b><br>当要修改数据的时候先是消息接受后，进行mysql的修改，修改后将消息发布给MQ，redis监听MQ消息进行更新缓存。这样的话对于数据的一致性就依靠于MQ的可靠性。</p><p><b>四：使用阿里的canal：</b><br>先是接受修改数据，写入数据库后，再通过canal对监听mysql的binlog，然后通知数据变更的情况进行缓存的更新。优点是对代码的零侵入，上面的多多少少多有对代码的侵入，</p><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>redis提供了两种的中持久化方式<b>RDB、AOF</b>其中的配置都在redis.conf里面进行具体的设置。</p><p><b>RDB</b>全称Redis Database Backup file（redis备份文件），也就是redis的数据快照，简单的来说就是将数据记录到磁盘中，这样的话当redis里面发生故障的时候，就可以从磁盘中通过读取快照文件快速恢复数据。<br>下面是主动备份的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save #由Redis主进程进行RDB，会阻塞所有的命令</span><br><span class="line">bgsave #开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><p>当然除了主动备份还有自动进行备份，在redis.conf里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#900秒内，如果至少又一个key被修改，则执行bgsave</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 1000</span><br></pre></td></tr></table></figure><p>RDB的执行机制就是：在bgsave进行时候先对主进程进行fork（copy-on-write技术）得到一个子进程，主进程和子进程fork时是对linux下特有的页表（虚拟内存映射关系表）拷贝，所以这个操作会特别快（阻塞也就时间很短），并且实现共享内存、可以同时对数据进行读操作，但是写操作是通过内存重新拷贝一个数据进行写操作，当然页表的对应关系也会更改，进而<br><b>AOF</b></p><h3 id="Redis的数据过期淘汰机制"><a href="#Redis的数据过期淘汰机制" class="headerlink" title="Redis的数据过期淘汰机制"></a>Redis的数据过期淘汰机制</h3><h2 id="Redis的分布式锁问题"><a href="#Redis的分布式锁问题" class="headerlink" title="Redis的分布式锁问题"></a>Redis的分布式锁问题</h2><h2 id="Redis的计数器"><a href="#Redis的计数器" class="headerlink" title="Redis的计数器"></a>Redis的计数器</h2><h2 id="Redis的保存Token、消息队列、延迟队列问题"><a href="#Redis的保存Token、消息队列、延迟队列问题" class="headerlink" title="Redis的保存Token、消息队列、延迟队列问题"></a>Redis的保存Token、消息队列、延迟队列问题</h2><h1 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h1><h2 id="Redis的集群模式"><a href="#Redis的集群模式" class="headerlink" title="Redis的集群模式"></a>Redis的集群模式</h2><h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><h2 id="Redis为什么这么块"><a href="#Redis为什么这么块" class="headerlink" title="Redis为什么这么块"></a>Redis为什么这么块</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>达内物联网框架</title>
      <link href="/2023/06/11/%E8%BE%BE%E5%86%85/"/>
      <url>/2023/06/11/%E8%BE%BE%E5%86%85/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="JDBC的认知"><a href="#JDBC的认知" class="headerlink" title="JDBC的认知"></a>JDBC的认知</h3><p>首先是为什么要使用ＪＤＢＣ？<br>JDBC:全称java database connectivity，是由SUN公司提供的一套操作数据库的标准规范。JDBC就是使用Java语言操作关系型数据库的一套API。所以：JDBC与数据库驱动的关系就像是接口与实现的关系。</p><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><p>JDBC规范（掌握四个核心对象，其实就是对应的类型）：<br>DriverManager:用于注册驱动<br>Connection: 表示与数据库创建的连接<br>Statement: 操作数据库sql语句的对象<br>ResultSet: 结果集或一张虚拟表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">DriverManager.registerDriver(new Driver());//这样的会导致被注册两次，因为源码上面就是注册了一次</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的优化"><a href="#JDBC的优化" class="headerlink" title="JDBC的优化"></a>JDBC的优化</h3><p>DriverManager.registerDriver(new com.mysql.jdbc.Driver())方法不建议使用原因有2个：一是：导致驱动被注册2次。二是：强烈依赖数据库的驱动jar。所以下面进行了优化：Class.forName(“com.mysql.jdbc.Driver”);同时又多了两种建立连接的方式：一：通过URl的路径方式方式：Class.forName(“com.mysql.jdbc.Driver”);二是：通过key-value键值对的形式包装再赋值：Properties info&#x3D;new Properties();info.setProperty(“user”, “root”);info.setProperty(“password”, “root”);Connection qiAo &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;gz”,info);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line"></span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line"></span><br><span class="line">Properties info=new Properties();</span><br><span class="line">info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">info.setProperty(&quot;password&quot;, &quot;root&quot;);</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,info);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的CRUD粗陋实现"><a href="#JDBC的CRUD粗陋实现" class="headerlink" title="JDBC的CRUD粗陋实现"></a>JDBC的CRUD粗陋实现</h3><p>Connection在返回结果时有两种常见方式：ResultSet类型的executeQuery(String sql)【这种的返回时用于sql里面的查询语句select语句时使用的返回方法，返回值是表类型的数据数据的开始为1】,int类型的executeUpdate(String sql)【这种的返回方法适用于增删改的操作，返回值是sql语句影响的条数】和一种boolean的方式boolean类型的execute(String sql)【返回值就是执行结果的对错，不能适合用在查询语句】 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//方法三增</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;insert into users(name,password,email,birthday) values(&#x27;zhaol&#x27;,&#x27;123456&#x27;,&#x27;zhaoliu@sina.com&#x27;,&#x27;1979-12-04&#x27;);&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法四删</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;DELETE FROM users WHERE users.id=4&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法五改</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;UPDATE users SET name=&#x27;null&#x27; WHERE id=5&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="JDBC的CRUD返回结果的包装"><a href="#JDBC的CRUD返回结果的包装" class="headerlink" title="JDBC的CRUD返回结果的包装"></a>JDBC的CRUD返回结果的包装</h3><p>其实是重拾java的内存结构（java各个属性的存放位置），java列表ArrayList的添加是地址添加不是值添加、以及泛型的定义：定义集合的存储类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义集合存放查到的数据    泛型:定义集合的存储类型</span><br><span class="line">ArrayList&lt;User&gt; list=new ArrayList();</span><br><span class="line">//5、处理结果,判断游标的下一行有没有数据有返回true反之 flase</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">User u=new User();</span><br><span class="line">u.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">u.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">u.setPassword(rs.getString(&quot;password&quot;));</span><br><span class="line">u.setEmail(rs.getString(&quot;email&quot;));</span><br><span class="line">u.setBirthday(rs.getDate(&quot;birthday&quot;));</span><br><span class="line">list.add(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="idea项目的配置"><a href="#idea项目的配置" class="headerlink" title="idea项目的配置"></a>idea项目的配置</h3><p>首先是新建项目，点击左上角的File，然后点击New和Project，新建项目先连续点击两次Next，然后就是项目名称、模板名字的命名了，Project name根据自己喜欢去命名，Module name根据需求进行命名。<br>然后就是配置了：<br>一：右键你的项目根目录，在下拉菜单里面找到你的Add Framework Support的选项，选择JEE下面的web选项，然后ok出来。<br>二：在项目里的web中的WEB-INF里面新建两个文件夹，一个是lib、另一个是classes。<br>三：点击左上角的File，在下拉菜单里面找到Project Structure并点击，在最左边选择Modules然后先选择最左边一栏的paths，选择Use module complie output path，并且将下面两个输入框都选择成上面在项目里面新建的classes的文件夹，最后点击右下角的Apply（不要退出）<br>四：点击Dependencies然后找到+号，点击添加JAR选择上面新建的lib文件夹，还有就是点击+号里面的librar将Tomcat添加到里面，在将添加那两个左边的选中框选上，后面可能会用到。<br>五：项目启动还没有配置，点击右上角绿色小锤子右边那个下拉框Edit Configurations，添加时在左边选择TomEE Server里面的Local，选中后将Applicattion server选择好我们的Tomcat的文件夹位置，最后再点击该窗口选项卡右边的Deployment，找到+号将四个菱形的选项添加上。</p><h3 id="idea使用Servlet的三种使用方式"><a href="#idea使用Servlet的三种使用方式" class="headerlink" title="idea使用Servlet的三种使用方式"></a>idea使用Servlet的三种使用方式</h3><p>在WEB-INF里面新建web.xml文件，每配置一个Servlet都要添加两个大标签<servlet>和<servlet-mapping>，前者是配置后者是访问路径，当用户通过URL的访问路径过来后先到<servlet-mapping>里面的对应的<url-pattern>然后再通过同<servlet-mapping>标签里面的<servlet-name>去找<servlet>相同的<servlet-name>，然后会再去到<servlet>相同标签下面的<servlet-class>，里面是我们Servlet对应项目的位置，通过这个去寻找项目里面对应的Servlet。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;!-- 配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet01&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet01&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!-- 配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet01&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet01&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;!--配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet02&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet02&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!--配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet02&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet02&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;!--配置servlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet03&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;cn.tedu.web.Servlet03&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;!--配置servlet的访问路径--&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;Servlet03&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/servlet/Servlet03&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>Servlet第一种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * servlet基于java语言开发的动态web资源的版本</span><br><span class="line"> * 本质上就是java代码</span><br><span class="line"> * 1入门：实现servlet接口的方式</span><br><span class="line"> *</span><br><span class="line"> * 生命周期：</span><br><span class="line"> * servlet在第一次被访问的时候创建</span><br><span class="line"> * 创建初servlet对象后，会立即调用init的当法进行初始化</span><br><span class="line"> * 之servlet后会一直驻留在内存中，为后续对该servlet的请求服务</span><br><span class="line"> * 每次请求此servlet都会造成方法的执行</span><br><span class="line"> * 知道服务器的关闭，或者web应用的移除、销毁servlet的销毁</span><br><span class="line"> * 销毁之前又会调用</span><br><span class="line"> * */</span><br><span class="line">public class Servlet01 implements Servlet &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 初始化的方法</span><br><span class="line">     * servlet容器在初始化servlet后立即执行的方法，进行初始化的操作</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line">        System.out.println(&quot;this is servlet01&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 就在这个里面进行接收，</span><br><span class="line">     * 业务处理的方法</span><br><span class="line">     * 每当有请求都会访问此方法，</span><br><span class="line">     * 接受代表请求的request的对象</span><br><span class="line">     * 代表相应的rsponse对象</span><br><span class="line">     * 在请求中获取数据 在响应中写出数据</span><br><span class="line">     * 可以在此方法中处理业务逻辑</span><br><span class="line">     *</span><br><span class="line">     * */</span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">/**</span><br><span class="line"> * 销毁方法</span><br><span class="line"> * 在servlet对象在销毁的时候之前会调用这个方法</span><br><span class="line"> * */</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;GG&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet第二种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建servlet的第二种方式</span><br><span class="line"> * 继承</span><br><span class="line"> * **/</span><br><span class="line">public class Servlet02 extends GenericServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;Servlet02~~~~service~~~&quot;);</span><br><span class="line">        servletResponse.getWriter().write(new Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet第三种使用方式，注解有对应的解读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建servlet的第三种方式</span><br><span class="line"> * 也是继承，但是需要进行重写方法</span><br><span class="line"> * **/</span><br><span class="line">public class Servlet03 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;收到GET请求，时间：&quot;+new Date());</span><br><span class="line">        //输出流</span><br><span class="line">        resp.getWriter().write(new Date().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面三个可以通过基本路径后面添加<url-pattern>里面的路径，进行使用。Servlet使用起来让我感觉和我使用的TCP里面的WebSocket时很像，主要的函数都是在开始前先调用一个方法，然后是每次访问都执行一个方法，还有就是结束销毁前进行一个方法。、</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><h3 id="JSP的使用，注册页面的实现，页面的引用"><a href="#JSP的使用，注册页面的实现，页面的引用" class="headerlink" title="JSP的使用，注册页面的实现，页面的引用"></a>JSP的使用，注册页面的实现，页面的引用</h3><p>先是将css和img里面要用到的css格式和图片进行导入，以及head头标签、foot尾部标签、index主页、rigis注册页面的资源导入。</p><p>然后就是在index.jsp文件显示头部标签、尾部标签jsp文件的格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 引入头部 --&gt;</span><br><span class="line">&lt;%@include file=&quot;_head.jsp&quot;%&gt;</span><br><span class="line">&lt;!-- 引入尾部 --&gt;</span><br><span class="line">&lt;%@include file=&quot;_foot.jsp&quot;%&gt;</span><br></pre></td></tr></table></figure><p>jsp文件其实就相当于servlet一样，可以在里面写入java代码，原理就和上面一样用一个&lt;%@ %&gt;的固定格式，当然也可以进行html的编写。</p><p>显然表单的检验，需要前端和后端两处进行验证，前端的验证是用来提醒用户、增强用户的体验。后端的验证是对于提交表单后的安全性验证，因为要避免恶意用户通过URl的方式直接在路径里面进行提交，那样的方式会避开前端的验证，所以后端的验证主要是对于安全性的考虑。</p><h3 id="先优化前端的代码，增强交互感觉"><a href="#先优化前端的代码，增强交互感觉" class="headerlink" title="先优化前端的代码，增强交互感觉"></a>先优化前端的代码，增强交互感觉</h3><p><b>先实现当用户提交信息的时候，对注册表单里面的数据进行非空的校验。</b></p><p>那么我们首先就要对表单提交后进行绑定事件，action里面是对应的servlet的，method里面是表单提交的方式，onsubmit里面就是表单提交在前端绑定的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;servlet/RegistServlet&quot; method=&quot;POST&quot; onsubmit=&quot;return checkForm()&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后就是进行checkForm前端方法的创建，通过script的便签和function创建函数。<br>函数里面要进行对表单数据非空判断，又因为我们的前端页面里面没有id字段只有name字段，那么就通过document.getElementsByName[0].value来拿到数据，var创建对象进行接收。<br>接收完数据又要对属性进行非空判断，使用if进行判断，判断完成后，如果通过弹窗提醒用户错误，那么就使用alert函数。<br>当然这样在多数据的表单里面太过于繁琐，所以我们可以先在新建一个空值的前端标签,里面进行一些设置，字体红色：style&#x3D;”color: red”这样方便用户直观的了解是错误填写提示，当然我们后面要对这个空标签赋值，那么我们需要一个唯一id进行命名，用于后面赋值：id&#x3D;”username_msg”格式为对应的输入栏的name值加上_msg，方便后期调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color: red&quot; id=&quot;username_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;color:red&quot; id=&quot;password_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;color:red&quot; id=&quot;password2_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">······</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么我们就不要用上面的弹窗提醒了，使用复制的形式进行页面显示报错信息提醒：document.getElementById(“username_msg”).innerText”&#x3D;用户名不能为空”，通过id的方式进行查找然后innerText进行附上需要的提示信息。代码如下面的注释里面的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;application/javascript&quot;&gt;</span><br><span class="line">function checkForm() &#123;</span><br><span class="line">    //拿到name是username的值</span><br><span class="line">    var username = document.getElementsByName(&quot;username&quot;)[0].value;</span><br><span class="line">    if (username == null || username==&quot;&quot;)&#123;</span><br><span class="line">        //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">        // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">        setMsg(&quot;username&quot;,&quot;用户名不能为空&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    var password = document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    if (password == null || password==&quot;&quot;)&#123;</span><br><span class="line">        //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">        // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">        setMsg(&quot;username&quot;,&quot;密码不能为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    ······</span><br><span class="line">    ······</span><br><span class="line">    return false;//不提交是因为我们的业务并没有做完</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之所以将他注释，是因为如果这样写法的话会非常多重复操作，造成代码的繁琐，那么我们就使用java的包装思想，进行相同代码的包装。那么应该知道我要做什么了吧，我们再创建一个setMsg函数进行获取显示的错误信息的标签操作，既然要获取对应的标签，我们需要先提供，本来的name，还有报错信息,具体方法就是上面的包装document.getElementById(id+”_msg”).innerText&#x3D;msg。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//封装的方法，用来获取某一篮对应要显示的错误信息</span><br><span class="line">    function setMsg(id,msg) &#123;</span><br><span class="line">        //将需要显示的错误信息进行显示</span><br><span class="line">        document.getElementById(id+&quot;_msg&quot;).innerText=msg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在我们进行了包装，但是我们还是需要进行var的创建、判断是否为空，不如我们在进行包装，判断非空交给另一个函数，我们只需要交给它name，如果错误要显示的错误信息就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function checkNull(name,msg)&#123;</span><br><span class="line">    var v=document.getElementsByName(name)[0].value;</span><br><span class="line">    if(v == null || v==&quot;&quot;)&#123;</span><br><span class="line">        //报错</span><br><span class="line">        setMsg(name,msg)</span><br><span class="line">        //到达这里说明等于空或者null，所以要返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //说明不为空或null</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们主函数就只需要传name和如果错误要显示的错误信息，但是我们如何判断其中都是T（去提交）还是其中有F（不让提交）呢？这时候我们使用递归的思想，创建一个canSub，开始我们给他true，后面的进行“与”的判断，T+T&#x3D;T，T+F&#x3D;F这样我们就实现了上面的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">function checkForm() &#123;</span><br><span class="line">    // //拿到name是username的值</span><br><span class="line">    // var username = document.getElementsByName(&quot;username&quot;)[0].value;</span><br><span class="line">    // if (username == null || username==&quot;&quot;)&#123;</span><br><span class="line">    //      //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">    //     // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">    //     setMsg(&quot;username&quot;,&quot;用户名不能为空&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line">    //</span><br><span class="line">    // var password = document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    // if (password == null || password==&quot;&quot;)&#123;</span><br><span class="line">    //     //alert(&quot;用户名不能为空&quot;)</span><br><span class="line">    //     // document.getElementById(&quot;username_msg&quot;).innerText&quot;=用户不能为空&quot;;</span><br><span class="line">    //     setMsg(&quot;username&quot;,&quot;密码不能为空&quot;);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    //用递归、与门的思想进行快速判断是否正确</span><br><span class="line">    //初始化一个“T”</span><br><span class="line">    var canSub=true;</span><br><span class="line">    //开始递归，从判断用户名开始，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;username&quot;,&quot;用户名不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    // checkNull(&quot;username&quot;,&quot;用户名不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断密码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;password&quot;,&quot;密码不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;password&quot;,&quot;密码不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认密码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;password2&quot;,&quot;确认密码不能为空&quot;)&amp;&amp; canSub;</span><br><span class="line">    //继续递归，开始判断确认名称，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;nickname&quot;,&quot;名称不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;nickname&quot;,&quot;名称不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认邮箱，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;email&quot;,&quot;邮箱不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;email&quot;,&quot;邮箱不能会空&quot;)</span><br><span class="line">    //继续递归，开始判断确认验证码，如果checkNull为空那么这个表单就不能让它提交</span><br><span class="line">    canSub=checkNull(&quot;valistr&quot;,&quot;验证码不能会空&quot;)&amp;&amp;canSub;</span><br><span class="line">    //checkNull(&quot;valistr&quot;,&quot;验证码不能会空&quot;)</span><br><span class="line"></span><br><span class="line">    //密码一致校验</span><br><span class="line">    var psw1=document.getElementsByName(&quot;password&quot;)[0].value;</span><br><span class="line">    var psw2=document.getElementsByName(&quot;password2&quot;)[0].value;</span><br><span class="line">    if(psw1!=null &amp;&amp; psw1!=&quot;&quot;&amp;&amp;psw2!=null &amp;&amp; psw2!=&quot;&quot;&amp;&amp; psw1!=psw2)&#123;</span><br><span class="line">        setMsg(&quot;password2&quot;,&quot;两次密码不一致&quot;)</span><br><span class="line">        canSub=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //邮箱格式的校验</span><br><span class="line">    var email=document.getElementsByName(&quot;email&quot;)[0].value;</span><br><span class="line">    if(email!=null &amp;&amp; email!=&quot;&quot; &amp;&amp; !/^\w+@\w+(\.\w+)+$/.test(email))&#123;</span><br><span class="line">        setMsg(&quot;email&quot;,&quot;邮箱的格式不正确&quot;)//报错</span><br><span class="line">        canSub=false;//结束提交</span><br><span class="line">    &#125;</span><br><span class="line">    return canSub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们还在主函数里面进行了两次密码的一致性判断，还有邮箱格式的判断，原理一样只是邮箱用到了“&#x2F;^\w+@\w+(.\w+)+$&#x2F;.test(email)”的<b>正则表达式</b>的判断。</p><p>现在我们的提交表单后的判断就成功了，但是在提交表单前面我们没有提示，这样用户在第一次的使用就会繁琐。我们现在进行表单提交前填写信息时的判断操作。</p><p><b>表单提交前填写信息时的判断：</b></p><p>我们要使用到onblur，这个作用就是当鼠标的焦点在这个标签移除时进行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;checkNull(&#x27;username&#x27;,&#x27;用户名不能为空&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure><p>那么我们的自动提示就完成了，但是会有bug，因为我们没有考虑到刷新的问题，当用户已经收到一次错误信息后，下一次改正时，我们只是不再发送消息，并没有清除上一次的消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> function checkNull(name,msg) &#123;</span><br><span class="line">    //清空每一次的错误消息</span><br><span class="line">    setMsg(name,&quot;&quot;)</span><br><span class="line">    var v=document.getElementsByName(name)[0].value;</span><br><span class="line">    if(v == null || v == &quot;&quot;)&#123;</span><br><span class="line">        setMsg(name,msg)</span><br><span class="line">        return false;//走到这里面就说明有空的,就返回false</span><br><span class="line">    &#125;</span><br><span class="line">    return  true;//进不去if就说明没有问题,返回true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后熟悉一下servlet的请求获取方法,getRequestURL() 获取请求地址,getQueryString() 获取请求的参数部分,getRemoteAddr() 获取客户机ip,getMethod() 获取请求的方式,getContextPath() 获取应用名称.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**  熟悉</span><br><span class="line"> * request:代表http请求的对象</span><br><span class="line"> * 功能1:获取客户机相关的信息</span><br><span class="line"> * getRequestURL() 获取请求地址</span><br><span class="line"> * getQueryString() 获取请求的参数部分</span><br><span class="line"> * getRemoteAddr() 获取客户机ip</span><br><span class="line"> * getMethod() 获取请求的方式</span><br><span class="line"> * getContextPath() 获取应用名称</span><br><span class="line"> */</span><br><span class="line">public class MyServlet01 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //请求地址</span><br><span class="line">        String url = request.getRequestURL().toString();</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        //请求资源路径</span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        System.out.println(uri);</span><br><span class="line">        //获取请求的参数部门</span><br><span class="line">        String qs = request.getQueryString();</span><br><span class="line">        System.out.println(qs);</span><br><span class="line">        //获取客户机的ip</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        System.out.println(ip);</span><br><span class="line">        //获取请求方式</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        System.out.println(method);</span><br><span class="line">        //应用名称</span><br><span class="line">        String cp = request.getContextPath();</span><br><span class="line">        System.out.println(cp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面的还有另一种方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**了解</span><br><span class="line"> * request功能2:获取请求头信息</span><br><span class="line"> * String getHeader(String var1); 接收请求头名字,返回请求值</span><br><span class="line"> * Enumeration&lt;String&gt; getHeaders(String var1); Enumeration是一个枚举对象,可以遍历,也就是说请求头中可能有多个一样的请求头</span><br><span class="line"> * Enumeration&lt;String&gt; getHeaderNames(); 获取所有请求头的名字的枚举</span><br><span class="line"> */</span><br><span class="line">public class MyServlet02 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        String host = request.getHeader(&quot;host&quot;);</span><br><span class="line">        System.out.println(host);</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;String&gt; headers = request.getHeaders(&quot;User-Agent&quot;);</span><br><span class="line">        while (headers.hasMoreElements())&#123;</span><br><span class="line">            String v = headers.nextElement();</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        &#125;</span><br><span class="line">        //获取所有请求参数的名字</span><br><span class="line">        Enumeration&lt;String&gt; names = request.getHeaderNames();</span><br><span class="line">        while (names.hasMoreElements())&#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            String value = request.getHeader(name);</span><br><span class="line">            System.out.println(name+&quot;:&quot;+value);</span><br><span class="line">        &#125;</span><br><span class="line">        //或者整型类型的请求头信息</span><br><span class="line">        int i = request.getIntHeader(&quot;Upgrade-Insecure-Requests&quot;);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        long mydate = request.getDateHeader(&quot;mydate&quot;);</span><br><span class="line">        System.out.println(mydate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>当然需要掌握的是下面常用的方法，在此方法里面还解决了，在<br>post提交时出现中文乱码的问题因为get请求里面，请求参数是在【地址】之后进行传输的，那么get请求就会在Tomcat里面的server.xml里面的配置进行解码，默认utf-8，post请求实在【实体内容】里面进行传输的，但是每个浏览器有不同的加密方式，Tomcat默认对实体内容解码方式是通过IS08859-1。所以要加上request.setCharacterEncoding(“utf-8”)来解决中文乱码的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 掌握</span><br><span class="line"> * request的功能3:获取请求的参数</span><br><span class="line"> */</span><br><span class="line">public class MyServlet03 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //获取指定名称的请求参数的值</span><br><span class="line">        String uname = request.getParameter(&quot;uname&quot;);</span><br><span class="line">        System.out.println(uname);</span><br><span class="line">        //获取指定名称请求参数的值们</span><br><span class="line">        String[] likes = request.getParameterValues(&quot;like&quot;);</span><br><span class="line">        System.out.println(Arrays.asList(likes));</span><br><span class="line">        //获取所有请求参数的名字</span><br><span class="line">        Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">        while (names.hasMoreElements())&#123;</span><br><span class="line">            String name = names.nextElement();</span><br><span class="line">            String value = request.getParameter(name);</span><br><span class="line">            System.out.println(name+&quot;:&quot;+value);</span><br><span class="line">        &#125;</span><br><span class="line">        //获取所有请求参数组成的map</span><br><span class="line">        Map&lt;String, String[]&gt; map = request.getParameterMap();//自动封装对象的时候用</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        //get请求里面，请求参数是在【地址】之后进行传输的，</span><br><span class="line">        //那么get请求就会在Tomcat里面的server.xml里面的配置进行解码，默认utf-8</span><br><span class="line"></span><br><span class="line">        //post请求实在【实体内容】里面进行传输的，但是每个浏览器有不同的加密方式，</span><br><span class="line">        //Tomcat默认对实体内容解码方式是通过IS08859-1</span><br><span class="line">        //请求参数乱码解决</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        String uname1 = request.getParameter(&quot;uname&quot;);</span><br><span class="line">        String uaddr1 = request.getParameter(&quot;uaddr&quot;);</span><br><span class="line">        System.out.println(uname1+&quot;==&quot;+uaddr1);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //super就是调用Tomcat帮我们写好的，Tonmcat就是如果过你调用我的我给你抛一个错误的</span><br><span class="line">        this.doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Servlet还有重要的特点就是servlet之间的跳转<b>请求跳转</b></p><p>首先是最简单的servlet和servlet的跳转，在这个过程中浏览器的地址不会发生变化，当然servlet不只于在两个之间跳转，可以多个servlet之间进行跳转，但是不可以循环跳转（1到2，2不可以再回到1），并且再转发的时候只有最后的一个servlet才可以进行资源的对外输出，其他中间的servlet如果输出都会在转发时被清空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 请求转发:服务器内部的资源跳转</span><br><span class="line"> * 一次请求一次响应</span><br><span class="line"> * 整个过程中是同一个request</span><br><span class="line"> * 浏览器的地址不会发生变化</span><br><span class="line"> * 可以多重转发,但是不能循环转发</span><br><span class="line"> * 转发过程中只有最后一个资源可以对外输出数据,其他资源的输出都会在转发时清空</span><br><span class="line"> */</span><br><span class="line">public class MyServlet04 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;MyServlet04~~~~~&quot;);</span><br><span class="line">        //发起请求转发</span><br><span class="line">        request.getRequestDispatcher(&quot;/servlet/MyServlet05&quot;).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然可以servlet之间的请求转发可以做到，那么数据的传输也要有所了解，其中对request的域对象的三个特征：生命周期、作用范围、主要功能需要进行细致了解。对于域对象的生命周期；就是再requset对象的创建到request的对象销毁。作用范围：再一次请求范围之内有效。主要的功能：再一个请求内进行（转发和包含、共享）数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//向request域中写入数据</span><br><span class="line">    request.setAttribute(&quot;name&quot;,&quot;apple&quot;);</span><br><span class="line">//从request中获取数据</span><br><span class="line">    String name = (String) request.getAttribute(&quot;name&quot;);</span><br><span class="line">//向response里面写入状态码</span><br><span class="line">    response.setStatus(403);</span><br><span class="line">//向response创建响应头</span><br><span class="line">    response.setHeader(&quot;asd&quot;,&quot;123&quot;);</span><br><span class="line">//向response写入响应头</span><br><span class="line">    response.addHeader(&quot;asd&quot;,&quot;456&quot;);</span><br></pre></td></tr></table></figure><p>当然技术需要和业务进行结合，现在servlet的数据传递进行拓展：</p><p><b>servlet的定时刷新：</b>就像支付宝的沙箱支付里面的回显操作，会先在一个页面里面进行显示提示文字，后面跟着几秒后进行刷新、跳转到XX界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.getWriter().write(&quot;恭喜注册成功,3秒后跳转首页&quot;);</span><br><span class="line">response.setHeader(&quot;refresh&quot;,&quot;3;url=&quot;+request.getContextPath()+&quot;/index.jsp&quot;);</span><br></pre></td></tr></table></figure><p><b>servlect的重定向：</b>重定向出现的业务是：当我们进行表单提交后，如果直接在当前servlet类里面的业务进行页面的跳转，那么如果用户此时刷新页面，那么就会显示是否进行重新提交表单数据，这样来说是不安全的。那么重定向的实现业务就是<b>解决刷新页面导致表单的重新提交</b>。显示解释重定向的原理：重定向就相当于是对一条servlet进行两次的请求和两次响应，当响应服务开始的时候，和之前一样携带着数据进行传递过来然后对数据进行逻辑判断，后面就不一样了，按以前的逻辑，我们要返回用户后面要跳转页面的URL，但是现在“重定向”我们需要进行返回一个302和一个location交给浏览器，这时候浏览器会根据location再进行一个访问，我们接收后再进行之后的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//基础代码</span><br><span class="line">response.setStatus(403);</span><br><span class="line">response.setHeader(&quot;location&quot;,request.getContextPath()+&quot;/index.jsp&quot;);</span><br><span class="line">//下面是简便的写法</span><br><span class="line">response.sendRedirect(request.getContextPath()+&quot;/index.jsp&quot;);</span><br></pre></td></tr></table></figure><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><h3 id="验证码的制作"><a href="#验证码的制作" class="headerlink" title="验证码的制作"></a>验证码的制作</h3><p>先是昨天的重定向时页面显示时中文乱码的问题（页面上面只要有？？？？）：首先是为什么都是？？？，因为我们在编码的时候没有指定要进行的编码方式，所以当浏览器解码的时候根本识别不出来是什么所以就只有问号。此前我们只进行过传入流的解码方式自定义（utf-8），还没有及逆行传出流的编码方式自定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br></pre></td></tr></table></figure><p>验证码先是使用老师提供的utile工具类，里面包装了不同字体，随机颜色，6个干扰线，-45到45的旋转，还有一个get方法出验证码校验文本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.utile;</span><br><span class="line"></span><br><span class="line">import java.awt.Color;</span><br><span class="line">import java.awt.Font;</span><br><span class="line">import java.awt.Graphics2D;</span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line">/**</span><br><span class="line"> * 动态生成图片</span><br><span class="line"> */</span><br><span class="line">public class VerifyCode &#123;</span><br><span class="line">// &#123;&quot;宋体&quot;, &quot;华文楷体&quot;, &quot;黑体&quot;, &quot;华文新魏&quot;, &quot;华文隶书&quot;, &quot;微软雅黑&quot;, &quot;楷体_GB2312&quot;&#125;</span><br><span class="line">private static String[] fontNames = &#123; &quot;宋体&quot;, &quot;华文楷体&quot;, &quot;黑体&quot;, &quot;微软雅黑&quot;,  &quot;楷体_GB2312&quot; &#125;;</span><br><span class="line">// 可选字符</span><br><span class="line">//&quot;23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ&quot;;</span><br><span class="line">private static String codes = &quot;23456789abcdefghjkmnopqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ&quot;;</span><br><span class="line">// 背景色</span><br><span class="line">private Color bgColor = new Color(255, 255, 255);</span><br><span class="line">// 基数(一个文字所占的空间大小)</span><br><span class="line">private int base = 30;</span><br><span class="line">// 图像宽度</span><br><span class="line">private int width = base * 4;</span><br><span class="line">// 图像高度</span><br><span class="line">private int height = base;</span><br><span class="line">// 文字个数</span><br><span class="line">private int len = 4;</span><br><span class="line">// 设置字体大小</span><br><span class="line">private int fontSize = 22;</span><br><span class="line">// 验证码上的文本</span><br><span class="line">private String text;</span><br><span class="line"></span><br><span class="line">private BufferedImage img = null;</span><br><span class="line">private Graphics2D g2 = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 生成验证码图片</span><br><span class="line"> */</span><br><span class="line">public void drawImage(OutputStream outputStream) &#123;</span><br><span class="line">// 1.创建图片缓冲区对象, 并设置宽高和图像类型</span><br><span class="line">img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">// 2.得到绘制环境</span><br><span class="line">g2 = (Graphics2D) img.getGraphics();</span><br><span class="line">// 3.开始画图</span><br><span class="line">// 设置背景色</span><br><span class="line">g2.setColor(bgColor);</span><br><span class="line">g2.fillRect(0, 0, width, height);</span><br><span class="line"></span><br><span class="line">StringBuffer sb = new StringBuffer();// 用来装载验证码上的文本</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">// 设置画笔颜色 -- 随机</span><br><span class="line">// g2.setColor(new Color(255, 0, 0));</span><br><span class="line">g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150),getRandom(0, 150)));</span><br><span class="line"></span><br><span class="line">// 设置字体</span><br><span class="line">g2.setFont(new Font(fontNames[getRandom(0, fontNames.length)], Font.BOLD, fontSize));</span><br><span class="line"></span><br><span class="line">// 旋转文字(-45~+45)</span><br><span class="line">int theta = getRandom(-45, 45);</span><br><span class="line">g2.rotate(theta * Math.PI / 180, 7 + i * base, height - 8);</span><br><span class="line"></span><br><span class="line">// 写字</span><br><span class="line">String code = codes.charAt(getRandom(0, codes.length())) + &quot;&quot;;</span><br><span class="line">g2.drawString(code, 7 + i * base, height - 8);</span><br><span class="line">sb.append(code);</span><br><span class="line">g2.rotate(-theta * Math.PI / 180, 7 + i * base, height - 8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.text = sb.toString();</span><br><span class="line"></span><br><span class="line">// 画干扰线</span><br><span class="line">for (int i = 0; i &lt; len + 2; i++) &#123;</span><br><span class="line">// 设置画笔颜色 -- 随机</span><br><span class="line">// g2.setColor(new Color(255, 0, 0));</span><br><span class="line">g2.setColor(new Color(getRandom(0, 150), getRandom(0, 150),</span><br><span class="line">getRandom(0, 150)));</span><br><span class="line">g2.drawLine(getRandom(0, 120), getRandom(0, 30), getRandom(0, 120),</span><br><span class="line">getRandom(0, 30));</span><br><span class="line">&#125;</span><br><span class="line">//TODO:</span><br><span class="line">g2.setColor(Color.GRAY);</span><br><span class="line">g2.drawRect(0, 0, this.width-1, this.height-1);</span><br><span class="line">// 4.保存图片到指定的输出流</span><br><span class="line">try &#123;</span><br><span class="line">ImageIO.write(this.img, &quot;JPEG&quot;, outputStream);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">// 5.释放资源</span><br><span class="line">g2.dispose();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取验证码字符串</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public String getCode() &#123;</span><br><span class="line">return this.text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 生成随机数的方法</span><br><span class="line"> */</span><br><span class="line">private static int getRandom(int start, int end) &#123;</span><br><span class="line">Random random = new Random();</span><br><span class="line">return random.nextInt(end - start) + start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*public static void main(String[] args) throws Exception &#123;</span><br><span class="line">VerifyCode vc = new VerifyCode();</span><br><span class="line">vc.drawImage(new FileOutputStream(&quot;f:/vc.jpg&quot;));</span><br><span class="line">System.out.println(&quot;执行成功~!&quot;);</span><br><span class="line">&#125;*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么需要再建一个servlet进行验证码点击的创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line">import cn.tedu.utile.VerifyCode;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class ServletCode extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //禁止浏览器的缓存,-1代表禁止缓存，三个都是禁止浏览器的缓存</span><br><span class="line">        response.setIntHeader(&quot;Expires&quot;,-1);</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);</span><br><span class="line">        response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);</span><br><span class="line">        //创建验证码对象</span><br><span class="line">        VerifyCode vc=new VerifyCode();</span><br><span class="line">        //生成验证码</span><br><span class="line">        vc.drawImage(response.getOutputStream());</span><br><span class="line">        //获取验证码</span><br><span class="line">        String code=vc.getCode();</span><br><span class="line">        //输出</span><br><span class="line">        System.out.println(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时前端也需要在验证码标签上面绑定点击事件，又因为地址发生变化的时候才会重新进行请求所以需要加上时间戳。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//函数的创建</span><br><span class="line">function changeImg(imgObj)&#123;</span><br><span class="line">    //地址发生变化的时候会重新进行请求</span><br><span class="line">    imgObj.src=&quot;&lt;%=request.getContextPath()%&gt;/servlet/ServletCode?time=&quot;+new Date().getTime();</span><br><span class="line">&#125;</span><br><span class="line">//事件的绑定</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td class=&quot;tds&quot;&gt;验证码：&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;valistr&quot;&gt;</span><br><span class="line">        &lt;img id=&quot;yzm_img&quot; onclick=&quot;changeImg(this)&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/servlet/ServletCode&quot; style=&quot;cursor: pointer&quot;/&gt;</span><br><span class="line">        &lt;span style=&quot;color: red&quot; id=&quot;valistr_msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure><h3 id="ajax的异步使用，优化前端"><a href="#ajax的异步使用，优化前端" class="headerlink" title="ajax的异步使用，优化前端"></a>ajax的异步使用，优化前端</h3><p>使用Ajax的话需要先在项目里面进行引入jquery.js的文件，位置为在web下面里面的js下面。AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX &#x3D; 异步 JavaScript 和 XML。Ajax的主要是在异步上面，用户在进行操作的时候就可以进行需要的服务，不会出现等待。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function checkUsername()&#123;</span><br><span class="line">    var isNoNull=checkNull(&quot;username&quot;,&quot;用户不为空&quot;)</span><br><span class="line">    if (isNoNull)&#123;</span><br><span class="line">        //不为空时</span><br><span class="line">        //检验存不存在</span><br><span class="line">        // $.ajax(&#123;</span><br><span class="line">        //</span><br><span class="line">        // &#125;)</span><br><span class="line">        var username=document.getElementsByName(&quot;username&quot;).value;</span><br><span class="line">        $.get(&quot;&lt;%= request.getContextPath()%&gt;/servlet/AjaxHasUserNameServlet&quot;,&#123;&quot;username&quot;:username&#125;,function (data)&#123;</span><br><span class="line">            alert(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">//AjaxHasUserEmailServlet</span><br><span class="line">public class AjaxHasUserEmailServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //解决乱码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        //获取请求参数</span><br><span class="line">        String useremail = request.getParameter(&quot;useremail&quot;);</span><br><span class="line">        System.out.println(useremail);</span><br><span class="line">        //检查邮箱是否存在</span><br><span class="line">        Connection conn=null;</span><br><span class="line">        PreparedStatement ps=null;</span><br><span class="line">        ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            conn= JDBCUtiles.getConn();</span><br><span class="line">            ps=conn.prepareStatement(&quot;select * from user where email=?&quot;);</span><br><span class="line">            ps.setString(1,useremail);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                //输出结果</span><br><span class="line">                response.getWriter().write(&quot;邮箱已存在&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                response.getWriter().write(&quot;邮箱可用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtiles.close(conn,ps,rs);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        //response.getWriter().write(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">//AjaxHasUserEmailServlet</span><br><span class="line">public class AjaxHasUserNameServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //解决乱码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        //获取请求参数</span><br><span class="line">        String username = request.getParameter(&quot;username&quot;);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        //检查用户名是否存在</span><br><span class="line">        Connection conn=null;</span><br><span class="line">        PreparedStatement ps=null;</span><br><span class="line">        ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            conn= JDBCUtiles.getConn();</span><br><span class="line">            ps=conn.prepareStatement(&quot;select * from user where username=?&quot;);</span><br><span class="line">            ps.setString(1,username);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                //输出结果</span><br><span class="line">                response.getWriter().write(&quot;用户名已存在&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                response.getWriter().write(&quot;用户名可用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtiles.close(conn,ps,rs);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        //response.getWriter().write(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.web;</span><br><span class="line"></span><br><span class="line">import cn.tedu.utile.JDBCUtiles;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line">public class AjaxHasUserNicknameServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //解决乱码</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        //获取请求参数</span><br><span class="line">        String usernickname = request.getParameter(&quot;usernickname&quot;);</span><br><span class="line">        System.out.println(usernickname);</span><br><span class="line">        //检查邮箱是否存在</span><br><span class="line">        Connection conn=null;</span><br><span class="line">        PreparedStatement ps=null;</span><br><span class="line">        ResultSet rs=null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            conn= JDBCUtiles.getConn();</span><br><span class="line">            ps=conn.prepareStatement(&quot;select * from user where nickname=?&quot;);</span><br><span class="line">            ps.setString(1,usernickname);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if(rs.next())&#123;</span><br><span class="line">                //输出结果</span><br><span class="line">                response.getWriter().write(&quot;昵称已存在&quot;);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                response.getWriter().write(&quot;昵称可用&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtiles.close(conn,ps,rs);</span><br><span class="line">        &#125;</span><br><span class="line">        //返回结果</span><br><span class="line">        //response.getWriter().write(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>会话技术:实现登录</b>因为http的请求是一种无状态的请求，所以每次的请求服务器并不知道是谁的，这时候我们就要用到了会话技术cookie和session了，cookie是将信息存储到浏览器，session是将信息交给服务器，这里我们用的是session，session也是request的域之一。<br>request的域其中的最基层的。就是request它只可以在一次访问请求之中进行数据的传递，<br>还有一个全域的，就是servletContext，它可以全部请求的数据访问，但是它的作用域导致其他的用户也会收到这个请求里面的东西。<br>这时候我们就需要进行session的会话技术了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将code存储到session域中</span><br><span class="line">HttpSession session = request.getSession();</span><br><span class="line">session.setAttribute(&quot;valistr&quot;, code);</span><br><span class="line"></span><br><span class="line">// 删除原有的session</span><br><span class="line">request.getSession().invalidate();// 删除session</span><br><span class="line">// 回到登录页</span><br><span class="line">response.sendRedirect(request.getContextPath() + &quot;/login.jsp&quot;);</span><br><span class="line"></span><br><span class="line"> // 验证成功，删除session中存储的验证码</span><br><span class="line">request.getSession().removeAttribute(&quot;valistr&quot;);</span><br></pre></td></tr></table></figure><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><h3 id="登陆页面的优化，添加动态的标签动态，"><a href="#登陆页面的优化，添加动态的标签动态，" class="headerlink" title="登陆页面的优化，添加动态的标签动态，"></a>登陆页面的优化，添加动态的标签动态，</h3><p>原理和上面的注册页面动态提示一样，不多做解释。</p><h3 id="记住用户"><a href="#记住用户" class="headerlink" title="记住用户"></a>记住用户</h3><p>就是cookie的使用，将用户名写进cookie里面，然后前端页面进行cookie遍历，遍历到需要的就进行获取显示，当然要设置中文编码，一个是作用域的设置，另一个是cookie的保留时间的设置，cookie的删除，直接将cookie进行保存时间为0的设置就行。</p><p>当然还要考虑，如果当用户第一次点击记住账号，第二次取消了记住密码，那么要在服务里面进行cookie的删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // 是否记住用户名</span><br><span class="line">if (&quot;true&quot;.equals(remname)) &#123;</span><br><span class="line">    // 记住，添加cookie</span><br><span class="line">    Cookie cookie = new Cookie(&quot;remname&quot;, URLEncoder.encode(username, &quot;utf-8&quot;));// 编码传输</span><br><span class="line">    cookie.setPath(request.getContextPath() + &quot;/login.jsp&quot;);</span><br><span class="line">    cookie.setMaxAge(60 * 60 * 24 * 14);// 十四天有效</span><br><span class="line">    response.addCookie(cookie);// cookie保存到本地</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 取消记住，删除cookie</span><br><span class="line">    Cookie cookie = new Cookie(&quot;remname&quot;, &quot;&quot;);</span><br><span class="line">    cookie.setPath(request.getContextPath() + &quot;/login.jsp&quot;);</span><br><span class="line">    cookie.setMaxAge(0);// 立即失效</span><br><span class="line">    response.addCookie(cookie);// cookie保存到本地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Cookie[] cookies = request.getCookies();</span><br><span class="line">    Cookie findC = null;</span><br><span class="line">    Cookie unameC = null;</span><br><span class="line">    Cookie pwdC = null;</span><br><span class="line">    if (cookies != null) &#123;</span><br><span class="line">        for (Cookie c : cookies) &#123;</span><br><span class="line">            if (&quot;remname&quot;.equals(c.getName())) &#123;</span><br><span class="line">                findC = c;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;username&quot;.equals(c.getName())) &#123;</span><br><span class="line">                unameC = c;</span><br><span class="line">            &#125;</span><br><span class="line">            if (&quot;password&quot;.equals(c.getName())) &#123;</span><br><span class="line">                pwdC = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String username = &quot;&quot;;</span><br><span class="line">    if (findC != null) &#123;        // 接收、解码</span><br><span class="line">        username = URLDecoder.decode(findC.getValue(), &quot;utf-8&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><p>无学习，自己做东西</p><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><p>答辩</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
