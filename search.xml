<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>黑马java面经总结</title>
      <link href="/2023/06/12/%E9%BB%91%E9%A9%ACjava%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2023/06/12/%E9%BB%91%E9%A9%ACjava%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="Redis的缓存问题"><a href="#Redis的缓存问题" class="headerlink" title="Redis的缓存问题"></a>Redis的缓存问题</h2><h3 id="Redis的穿透"><a href="#Redis的穿透" class="headerlink" title="Redis的穿透"></a>Redis的穿透</h3><p><b>Redis的穿透概念：</b>举个例子不陌生的例子：<b>网络攻击</b>，其中就可能是他人通过某些手段获取到了你的请求URL，然后用你数据库<b>根本不存在的数据来疯狂访问你的项目</b>，又因为正常的项目都是在用户请求数据的时候先去Redis里面进行查询，查询不到了之后才会去数据库里面查询，数据库里面查询到之后会将数据放到Redis里面，这样用户下次的访问就可以在Redis里面进行快速的回应。这样就会发现黑客用大量的虚假数据进行访问时，就会都跳过Reids前往数据库进行查询，这样的话数据库的I&#x2F;O就会压力负载变大，当达到临界值的时候就会将数据库搞崩。这样就相当于<b>Redis被穿过去了直接将压力给到了数据库</b>，所以这个问题就是Redis“穿透”问题。</p><p><b>Redis穿透问题的解决方法：</b></p><p><b>一：缓存空数据：</b>查询结果为空的时候仍把这个空数据进行缓存。<br>优点：简单。    缺点：消耗内存，可能会发生不一致的问题。</p><p><b>二：布隆过滤器</b><br>&amp;esmp<b>运行原理：</b>比如在id查询时先通过查询布隆过滤器，如果不存在就直接返回，如果在布隆过滤器内存在才去Redis里面查询，（也就是在redis前查询前又加了一个过程），当然使用这种的话有一个关键的前提（缓存预热时还要对布隆过滤器进行预热）</p><p><b>布隆过滤器原理：</b>其实就是bitmap（位图）：一个以（bit）位为单位的数组，数组中每一个单位都只能存储0或1。预热时就是将一个一个值（id）进行多次hash函数后获取hash的值，然后将那个位置的值（hash后id）改成1。查询时就使用相同的hash函数进行获取hash值，判断hash值的位置是否位1，是就证明redis存在，不是则相反，当然这样的话肯定会存在误判（比如库里面只有1和2，hash后1对应的是1、3、5，2对应的是2、4、6，现在来了个3，hash后假如是：1、2、3，那么所有的值也是1，但是库里面却没有3的数据，这就是误判），所以布隆过滤器可以调整容错率。<br>优点：内存占用较小，没有多余的key。    缺点：存在误判的问题。</p><h3 id="Redis的击穿"><a href="#Redis的击穿" class="headerlink" title="Redis的击穿"></a>Redis的击穿</h3><p><b>Redis的击穿概念：</b>在现实使用中除了人为破坏当然还有<b>意外或者无意造成破坏</b>，其中就可能redis里面“碰巧”<b>一个数据过期后同一时间大部分数据进行访问</b>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又又又拉满了，当接近<b>“击穿电压”【临界值】</b>时数据库就会又被搞崩，所以这个问题就是Redis“击穿”问题【redis没有管理好“电压”，导致数据库“用电器”被击穿了】。</p><p><b>Redis击穿问题的解决方法：</b></p><p><b>一：添加互斥锁：</b>多个线程里面最先的那个先发现redis里面没有，申请互斥锁并成功，那么就去数据库查询，后面的线程虽然redis里面查询没有，但是因为申请不到互斥锁，就只能休眠一会，然后自动重新从头开始redis访问，当最前面的线程查询到数据库里面的数据，并且将数据写入缓存时，才释放互斥锁。<br>优点：强一致性。【不是绝对】    缺点：性能差【只有一个能拿到锁，其他都只能休眠，造成用户只能干等的局面】。  适用于银行金融，需要强一致性的场所。</p><p><b>二：逻辑过期</b>：其实就像萌新的我刚刚遇到这个问题，第一个想法就是<b>不设置过期时间</b>，但是这样的话redis里面的数据时效性就会被破坏，那么就<b>再添加一个字段为“保质期”</b>当后面程序拿到了这个数据，一分析居然是“过期的”就会去申请互斥锁，那么拿到互斥多锁的那个线程就会，再多开一个新线程，新线程去数据库查询和写入缓存、释放锁操作。当然在这期间原本那个线程和后面申请不到互斥锁的线程就会带着过期的数据返回，不会盲目等待，可以先去干别。直到新线程重新写入缓存、修改逻辑、过期时间、后这个数据就可以使用了，再来进行访问。<br>优点：高可用性，性能也好。    缺点：一致性差。  适用于互联网这种高可用性的场所</p><h3 id="Redis的雪崩"><a href="#Redis的雪崩" class="headerlink" title="Redis的雪崩"></a>Redis的雪崩</h3><p><b>Redis的雪崩概念：</b>在实际使用redis时如果不规范，也会造成<b>意外或者无意</b>造成破坏，其中就可能redis里面“碰巧”<b >出现同一时间大量的缓存key同时失效或者redis宕机了</b>，此时这些大量的合规数据如果不加控制就会进入数据库进行查询，这样就将数据库的压力又拉又满了，而导致的数据库的压力增大就是redis的雪崩。</p><p><b>Redis雪崩问题的解决方法：</b></p><p><b>一：给不同的key的TTl添加随机值：</b>从过期时间上面的更改。<br><b>二：利用Redis的集群提高服务的的可用性：</b>“哨兵模式”、“集群模式”从redis性能上面的更改。<br><b>三：给缓存业务添加降级限流策略：</b>使用“Ngxin”、“spring cloud gateway”从业务上面进行更改。<br><b>四：给业务添加多级缓存：</b>“Guava”、“Caffeine”通过多添加缓存。</p><h3 id="Redis的双写一致性"><a href="#Redis的双写一致性" class="headerlink" title="Redis的双写一致性"></a>Redis的双写一致性</h3><p>双写一致性其实就是：<b>如何保持redis和数据库的数据一致</b>。那么就是对数据库和缓存的数据更新处理。</p><p><b>双写一致性的方法：</b><br><b>一：延迟双删:</b><br>首先是为什么要进行延迟双删？因为如果只是数据库和redis的单次删除，那么无论如何处理（先删除数据库、先删除redis）都会导致数据的不一致导致脏读现象的出现。</p><p>先操作数据库再删除redis的话，理想的情况下是：当我们操作完数据库之后，并且将数据在redis里面删除，下一个线程查询不到redis里面的数据的时候，开始到数据库里面查询数据之后再写入redis里面，后面的的请求再在redis里面进行数据的获取。但是会出现一种情况就是当数据库被操作之前，redis里面的数据过期了或者被淘汰掉了，那么会有一个线程到数据库里面进行查询，这条线程查询到的是一个未被更新的数据，但是它还没有写入redis里面的时候我们进行了操作数据库和删除redis的操作，那么当我们结束后，读取到未被更新的数据的线程开始重新进行，将未被更新的数据写入redis里面，，导致之后出现脏读现象。<br>先删除redis后再操作数据库的话，理想情况下是：当我们删除数据和操作数据库之后，再来请求，发现reids里面没有数据，那么就会想数据库进行访问，然后再将数据库访问到的新数据写入到redis里面。但是会出现一种情况就是：当我们在删除redis数据完成之后，但是在书库操作之前，来了个线程，它先在redis里面查询发现没有数据，那么就会去数据库访问，但是我们还没有更新数据，就导致该线程查询到了未更新的数据，这是我们再进行是你出redis，操作数据库完成之后，查询到违背更新的数据的线程将数据返回并且还写入到redis里面，导致之后数据的脏读现象发生。</p><p>所以我们要避免脏读现象的出现最简单的就是“延迟双删”的操作，也和字面意思一样，当我们无论是先删除redis还是操作数据库，完成流程之后等一段时间再对reids进行二次删除，那么就不会再出现脏读的现象了。</p><p><b>二：分布式锁：</b><br>我们也可以进行加锁，首先是最简单的，无论是读还是写都要进行拿锁，拿到锁后才能进行数据对应的操作。（这样的话是强一致性，但是对于性能方面上是十分差的）</p><p>那么我们可以想一下redis里面的数据肯定是读多写少的数据，那么通过排他锁（读和写互斥）、共享锁（读读不互斥，写互斥）可以进一步提高性能。</p><p>当我们要进行读操作的时候进行添加共享锁，多个线程的读都不会影响，当进行写操作的时候添加一个排他锁，这样的话就读就无法进行，从而实现强一致性避免脏读，但是这样的话当我们进行写的时候读就无法进行，那么效率和性能还是很差的。是用在需要强一致性的场合才用。</p><p>当然除了强一致性的特殊场合，还有对一致性要求不高但是对性能要求高的场所，还有两种方案：</p><p><b>三：使用MQ：</b><br>当要修改数据的时候先是消息接受后，进行mysql的修改，修改后将消息发布给MQ，redis监听MQ消息进行更新缓存。这样的话对于数据的一致性就依靠于MQ的可靠性。</p><p><b>四：使用阿里的canal：</b><br>先是接受修改数据，写入数据库后，再通过canal对监听mysql的binlog，然后通知数据变更的情况进行缓存的更新。优点是对代码的零侵入，上面的多多少少多有对代码的侵入，</p><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><p>redis提供了两种的中持久化方式<b>RDB、AOF</b>其中的配置都在redis.conf里面进行具体的设置。</p><p><b>RDB</b>全称Redis Database Backup file（redis备份文件），也就是redis的数据快照，简单的来说就是将数据记录到磁盘中，这样的话当redis里面发生故障的时候，就可以从磁盘中通过读取快照文件快速恢复数据。<br>下面是主动备份的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save #由Redis主进程进行RDB，会阻塞所有的命令</span><br><span class="line">bgsave #开启子进程执行RDB，避免主进程受到影响</span><br></pre></td></tr></table></figure><p>当然除了主动备份还有自动进行备份，在redis.conf里面</p><p><b>AOF</b></p><h3 id="Redis的数据过期淘汰机制"><a href="#Redis的数据过期淘汰机制" class="headerlink" title="Redis的数据过期淘汰机制"></a>Redis的数据过期淘汰机制</h3><h2 id="Redis的分布式锁问题"><a href="#Redis的分布式锁问题" class="headerlink" title="Redis的分布式锁问题"></a>Redis的分布式锁问题</h2><h2 id="Redis的计数器"><a href="#Redis的计数器" class="headerlink" title="Redis的计数器"></a>Redis的计数器</h2><h2 id="Redis的保存Token、消息队列、延迟队列问题"><a href="#Redis的保存Token、消息队列、延迟队列问题" class="headerlink" title="Redis的保存Token、消息队列、延迟队列问题"></a>Redis的保存Token、消息队列、延迟队列问题</h2><h1 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h1><h2 id="Redis的集群模式"><a href="#Redis的集群模式" class="headerlink" title="Redis的集群模式"></a>Redis的集群模式</h2><h2 id="Redis的事务"><a href="#Redis的事务" class="headerlink" title="Redis的事务"></a>Redis的事务</h2><h2 id="Redis为什么这么块"><a href="#Redis为什么这么块" class="headerlink" title="Redis为什么这么块"></a>Redis为什么这么块</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2023/06/11/JDBC/"/>
      <url>/2023/06/11/JDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="JDBC的认知"><a href="#JDBC的认知" class="headerlink" title="JDBC的认知"></a>JDBC的认知</h3><p>首先是为什么要使用ＪＤＢＣ？<br>JDBC:全称java database connectivity，是由SUN公司提供的一套操作数据库的标准规范。JDBC就是使用Java语言操作关系型数据库的一套API。所以：JDBC与数据库驱动的关系就像是接口与实现的关系。</p><h3 id="JDBC的使用"><a href="#JDBC的使用" class="headerlink" title="JDBC的使用"></a>JDBC的使用</h3><p>JDBC规范（掌握四个核心对象，其实就是对应的类型）：<br>DriverManager:用于注册驱动<br>Connection: 表示与数据库创建的连接<br>Statement: 操作数据库sql语句的对象<br>ResultSet: 结果集或一张虚拟表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">DriverManager.registerDriver(new Driver());//这样的会导致被注册两次，因为源码上面就是注册了一次</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的优化"><a href="#JDBC的优化" class="headerlink" title="JDBC的优化"></a>JDBC的优化</h3><p>DriverManager.registerDriver(new com.mysql.jdbc.Driver())方法不建议使用原因有2个：一是：导致驱动被注册2次。二是：强烈依赖数据库的驱动jar。所以下面进行了优化：Class.forName(“com.mysql.jdbc.Driver”);同时又多了两种建立连接的方式：一：通过URl的路径方式方式：Class.forName(“com.mysql.jdbc.Driver”);二是：通过key-value键值对的形式包装再赋值：Properties info&#x3D;new Properties();info.setProperty(“user”, “root”);info.setProperty(“password”, “root”);Connection qiAo &#x3D; DriverManager.getConnection(“jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;gz”,info);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//创建链接1、注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//与对应的数据库进行链接 2、创建连接</span><br><span class="line"></span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line"></span><br><span class="line">Properties info=new Properties();</span><br><span class="line">info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">info.setProperty(&quot;password&quot;, &quot;root&quot;);</span><br><span class="line">Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz&quot;,info);</span><br><span class="line">//先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">Statement sql=qiAo.createStatement();</span><br><span class="line">String rs=&quot;select * from users&quot;; </span><br><span class="line">//4、执行sql语句，并返回结果</span><br><span class="line">ResultSet re=sql.executeQuery(rs);</span><br><span class="line">//5、处理结果</span><br><span class="line">while(re.next()) &#123;</span><br><span class="line">    System.out.println(re.getObject(1));</span><br><span class="line">    System.out.println(re.getObject(2));</span><br><span class="line">    System.out.println(re.getObject(3));</span><br><span class="line">    System.out.println(re.getObject(4));</span><br><span class="line">    System.out.println(re.getObject(5));</span><br><span class="line">&#125;</span><br><span class="line">//6关闭资源</span><br><span class="line">sql.close();</span><br><span class="line">qiAo.close();</span><br><span class="line">re.close();</span><br></pre></td></tr></table></figure><h3 id="JDBC的CRUD粗陋实现"><a href="#JDBC的CRUD粗陋实现" class="headerlink" title="JDBC的CRUD粗陋实现"></a>JDBC的CRUD粗陋实现</h3><p>Connection在返回结果时有两种常见方式：ResultSet类型的executeQuery(String sql)【这种的返回时用于sql里面的查询语句select语句时使用的返回方法，返回值是表类型的数据数据的开始为1】,int类型的executeUpdate(String sql)【这种的返回方法适用于增删改的操作，返回值是sql语句影响的条数】和一种boolean的方式boolean类型的execute(String sql)【返回值就是执行结果的对错，不能适合用在查询语句】 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//方法三增</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;insert into users(name,password,email,birthday) values(&#x27;zhaol&#x27;,&#x27;123456&#x27;,&#x27;zhaoliu@sina.com&#x27;,&#x27;1979-12-04&#x27;);&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法四删</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;DELETE FROM users WHERE users.id=4&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">////方法五改</span><br><span class="line">//public static void main(String[] args) throws Exception &#123;</span><br><span class="line">////创建链接1、注册驱动</span><br><span class="line">//Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">////与对应的数据库进行链接 2、创建连接</span><br><span class="line">//Connection qiAo = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/gz?user=root&amp;password=root&quot;);</span><br><span class="line">////先获取对应的SQL语句3、得到执行sql语句的Statement对象</span><br><span class="line">//Statement sql=qiAo.createStatement();</span><br><span class="line">//String rs=&quot;UPDATE users SET name=&#x27;null&#x27; WHERE id=5&quot;; </span><br><span class="line">////4、执行sql语句，并返回结果</span><br><span class="line">//int re=sql.executeUpdate(rs);</span><br><span class="line">////5.输出结果</span><br><span class="line">//System.out.println(&quot;一共影响力&quot;+re+&quot;行&quot;);</span><br><span class="line">////6关闭资源</span><br><span class="line">//sql.close();</span><br><span class="line">//qiAo.close();</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><h3 id="JDBC的CRUD返回结果的包装"><a href="#JDBC的CRUD返回结果的包装" class="headerlink" title="JDBC的CRUD返回结果的包装"></a>JDBC的CRUD返回结果的包装</h3><p>其实是重拾java的内存结构（java各个属性的存放位置），java列表ArrayList的添加是地址添加不是值添加、以及泛型的定义：定义集合的存储类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义集合存放查到的数据    泛型:定义集合的存储类型</span><br><span class="line">ArrayList&lt;User&gt; list=new ArrayList();</span><br><span class="line">//5、处理结果,判断游标的下一行有没有数据有返回true反之 flase</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">User u=new User();</span><br><span class="line">u.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">u.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">u.setPassword(rs.getString(&quot;password&quot;));</span><br><span class="line">u.setEmail(rs.getString(&quot;email&quot;));</span><br><span class="line">u.setBirthday(rs.getDate(&quot;birthday&quot;));</span><br><span class="line">list.add(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/06/08/hello-world/"/>
      <url>/2023/06/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客测试，我用的是<a href="https://hexo.io/">Hexo</a>的框架+git管理代码：<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上，我是win10的系统上从零搭建的同时参考大佬们的教程，现在对自己在该项目的所遇到的问题、常见命令进行总结和复习.</p><h2 id="下面是大致的流程"><a href="#下面是大致的流程" class="headerlink" title="下面是大致的流程"></a>下面是大致的流程</h2><h3 id="首先是Node-js的安装"><a href="#首先是Node-js的安装" class="headerlink" title="首先是Node.js的安装"></a>首先是Node.js的安装</h3><p>现在Node.js的官网下载你需要的版本，(本项目用的是v18.16.0，x64版本)然后一直Next进行下去(中间记得点击接受协议，还有选择安装的位置，“E:\NodeJS”是我的安装位置)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node</span><br></pre></td></tr></table></figure><p>当然，其实检查Node和Npm的版本还有其他的命令，但是这些命令，即使你已经配置好环境变量在普通cmd上直接运行会发现无法运行，那么我推荐你使用cmd的管理员模式运行，就可以运行起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>安装完成后需要进行配置环境变量：先右键点击“此电脑”选中“属性”，然后划到最下角点击“高级系统设置”，弹出一个弹窗后点击弹窗右下角的“环境变量”，就会又弹出的弹窗，在的下半部分找到变量为“Path”点击编辑，然后新建一个将Node.js安装目录放上去就行，然后一路确定回来，这样Node.js就安装好啦。</p><h3 id="还有是Node-js的下载调整"><a href="#还有是Node-js的下载调整" class="headerlink" title="还有是Node.js的下载调整"></a>还有是Node.js的下载调整</h3><p>还有一点就是npm的默认下载速度可能很慢，可以考虑将它换成淘宝镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><h3 id="然后就是hexo的安装"><a href="#然后就是hexo的安装" class="headerlink" title="然后就是hexo的安装"></a>然后就是hexo的安装</h3><p>直接上代码！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli g</span><br></pre></td></tr></table></figure><p>好啦，这样就将最基础的编辑环境配好了。</p><h3 id="现在让我们开始github上传配置（编码一小时，配置大半天）"><a href="#现在让我们开始github上传配置（编码一小时，配置大半天）" class="headerlink" title="现在让我们开始github上传配置（编码一小时，配置大半天）"></a>现在让我们开始github上传配置（编码一小时，配置大半天）</h3><p>首先是<a href="https://github.com/">github</a>上面注册一个账号。然后就是下载<a href="https://git-scm.com/download">git</a>。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
